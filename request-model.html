<!--
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="request-base-model.html">
<link rel="import" href="../app-pouchdb-quick-search/pouchdb-quick-search.html">

<script>
/**
 * Events based access to saved request datastore.
 *
 * Note: **All events must be cancelable.** When the event is cancelled
 * by an instance of the element it won't be handled again by other instance
 * that possibly exists in the DOM.
 *
 * Cancellable event is a request to models for change. Non-cancellable event
 * is a notification for views to update their values. For example
 * `request-object-changed` event notifies model to update object in
 * the datastore if the event is cancelable and to update views if it's not
 * cancellable.
 *
 * Each handled event contains the `result` property on the `detail` object. It
 * contains a `Promise` object with a result of the operation. Also,
 * for update / delete events the same non-cancelable event is fired.
 *
 * Events handled by this element are cancelled and propagation of the event is
 * stopped.
 *
 * Supported operations:
 *
 * -   Read request object (`request-object-read`)
 * -   Update name only (`request-name-changed`)
 * -   Update request object (`request-object-changed`)
 * -   Delete object (`request-object-deleted`)
 * -   Deletes list of request objects (`request-objects-deleted`)
 *
 * ## Request object types
 *
 * There are two request object types: `saved-requests` and `history-requests`.
 * Each event must contain a `type` property to determine which database
 * to query for an object.
 *
 * ### Events description
 *
 * #### `request-object-read` event
 *
 * Reads a request object from the datastore.
 *
 * ##### Properties
 *
 * -   `id` (String, required) ID of the datastore entry
 * -   `rev` (String, optional) Specific revision to retrieve from the
 * datastore. Latest by default.
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-object-read', {
 *    detail: { id: 'some-id', type: 'saved-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(request => console.log(request));
 * }
 * ```
 *
 * #### `request-name-changed` Event
 *
 * Changes name of a request. Promise result has updated `name` and
 * `_rev` properties.
 * This operation deletes old object because it changes the `name` of
 * the request that is used to build the datastore key.
 *
 * ##### Properties
 * -   `id` (String, required if `project` is not set) ID of the datastore entry
 * -   `request` (Object, required if `id` is not set) The database entity
 * -   `name` (String, required) New name of the project. It doesn't matter
 * if `project` property already has new name.
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-name-changed', {
 *    detail: { id: 'some-id', name: 'new name', type: 'history-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(request => console.log(request));
 * }
 * ```
 *
 * #### `request-object-changed` event
 *
 * Updates / saves new object in the datastore.
 *
 * ##### Properties
 *
 * -   `request` (Object, required) An object to store
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 **
 * ```javascript
 * var event = new CustomEvent('request-object-changed', {
 *    detail: { request: {...}, type: 'saved-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(request => console.log(request));
 * }
 * ```
 *
 * #### `request-object-deleted` event
 *
 * Deletes the object from the datastore. This operation fires
 * `request-object-deleted` custom event. Promise returns object's new
 * `_rev` value.
 *
 * ##### Properties
 * -   `id` (String, required) ID of the datastore entry
 * -   `rev` (String, optional) The `_rev` property of the PouchDB datastore
 * object. If not set it will use latest revision.
 * -   `type` {String, required} Request object type. Either `saved-requests` or
 * `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-object-deleted', {
 *    detail: { id: 'some-id', type: 'saved-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(newRev => console.log(newRev));
 * }
 * ```
 *
 * #### `request-objects-deleted` event
 *
 * Removes list of requests in batch operation. Promise results to the map
 * where keys are request ids and values are new revision hash.
 *
 * ##### Properties
 *
 * -   `items` (Array, required) List of IDs to delete
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-objects-deleted', {
 *    detail: {
 *      items: ['some-id', 'other-id'],
 *      type: 'saved-requests'
 *    },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 *  });
 *  if (event.defaultPrevented) {
 *    event.detail.result.then(deleted => console.log(deleted));
 *  }
 *  ```<link rel="import" href="../polymer/polymer.html">
 *  <link rel="import" href="../app-pouchdb/pouchdb.html">
 *
 * #### `request-objects-undeleted` event
 *
 * Restores previously deleted requests from the history.
 * It searches in the revision history of each object to find a revision before
 * passed `_rev` and restores this object as a new one in the revision tree.
 *
 * This operation fires `request-object-deleted` custom event. Promise returns
 * request objects with updated `_rev` value.
 *
 * ##### Properties
 *
 * -   `items` (Array, required) List of requests to restore. It required `_id`
 * and `_rev` properties to be set on each object. The `_rev` property must be
 * a revision updated after the deletion of the object.
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-objects-deleted', {
 *    detail: {
 *      items: [{_id: 'some-id', '_rev': '2-xyz']},
 *      type: 'saved-requests'
 *    },
 *    bubbles: true,<link rel="import" href="../polymer/polymer.html">
 * <link rel="import" href="../app-pouchdb/pouchdb.html">
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(restored => console.log(restored));
 * }
 * ```
 *
 * @polymer
 * @customElement
 * @memberof LogicElements
 * @extends RequestBaseModel
 */
class RequestModel extends RequestBaseModel {
  /* global RequestBaseModel */
  static get is() {return 'request-model';}

  static get properties() {
    return {
      /**
       * When set it skips request indexing.
       */
      noIndexing: Boolean,
      _workerRequestId: {
        type: Number,
        value: function() {
          return 0;
        }
      },
      _workerPromises: {
        type: Array,
        value: []
      }
    };
  }
  /**
   * @constructor
   */
  constructor() {
    super();
    this._handleRead = this._handleRead.bind(this);
    this._handleNameChange = this._handleNameChange.bind(this);
    this._handleObjectSave = this._handleObjectSave.bind(this);
    this._handleObjectDelete = this._handleObjectDelete.bind(this);
    this._handleObjectsDelete = this._handleObjectsDelete.bind(this);
    this._handleObjectsUndelete = this._handleObjectsUndelete.bind(this);
    this._saveRequestHandler = this._saveRequestHandler.bind(this);
    this._onIndexWorkerData = this._onIndexWorkerData.bind(this);
    this._onIndexWorkerError = this._onIndexWorkerError.bind(this);
    this._handleQuery = this._handleQuery.bind(this);
  }
  /**
   * Adds event listeners.
   * @param {HTMLElement} node
   */
  _attachListeners(node) {
    node.addEventListener('save-request', this._saveRequestHandler);
    node.addEventListener('request-object-read', this._handleRead);
    node.addEventListener('request-name-changed', this._handleNameChange);
    node.addEventListener('request-object-changed', this._handleObjectSave);
    node.addEventListener('request-object-deleted', this._handleObjectDelete);
    node.addEventListener('request-objects-deleted', this._handleObjectsDelete);
    node.addEventListener('request-objects-undeleted',
      this._handleObjectsUndelete);
    node.addEventListener('request-query', this._handleQuery);
  }
  /**
   * Removes event listeners.
   * @param {HTMLElement} node
   */
  _detachListeners(node) {
    node.removeEventListener('save-request', this._saveRequestHandler);
    node.removeEventListener('request-object-read', this._handleRead);
    node.removeEventListener('request-name-changed', this._handleNameChange);
    node.removeEventListener('request-object-changed', this._handleObjectSave);
    node.removeEventListener('request-object-deleted',
      this._handleObjectDelete);
    node.removeEventListener('request-objects-deleted',
      this._handleObjectsDelete);
    node.removeEventListener('request-objects-undeleted',
      this._handleObjectsUndelete);
    node.removeEventListener('request-query', this._handleQuery);
    this._unregisterWorker();
  }
  /**
   * A handler for `save-request-data` custom event. It's special event to
   * save / update request data dispatched by the request editor.
   *
   * @param {CustomEvent} e
   */
  _saveRequestHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const request = e.detail.request;
    const projects = e.detail.projects;
    const options = e.detail.options;
    if (!request._id) {
      request._id = this.uuid.generate();
    }
    let p;
    if (projects && projects.length) {
      p = this._createProjects(projects, request._id);
    } else {
      p = Promise.resolve();
    }
    e.detail.result = p
    .then((projectIds) => {
      if (!request.projects) {
        request.projects = [];
      }
      if (request.legacyProject) {
        if (request.projects.indexOf(request.legacyProject) === -1) {
          request.projects.push(request.legacyProject);
        }
        delete request.legacyProject;
      }
      if (projectIds) {
        request.projects = request.projects.concat(projectIds);
      }
      request.type = 'saved';
      return this.saveRequest(request, options);
    });
  }
  /**
   * Create projects from project names.
   * It is used when creating a request with a new project.
   *
   * @param {Array<String>} names Names of projects
   * @param {?String} requestId Request ID to add to the projects.
   * @return {Promise<Array<String>>} Promise resolved to list of project IDs
   */
  _createProjects(names, requestId) {
    const requests = [];
    if (requestId) {
      requests.push(requestId);
    }
    const projects = names.map((name) => {
      return {
        updated: Date.now(),
        order: 0,
        requests,
        name
      };
    });
    return this.projectDb.bulkDocs(projects)
    .then((response) => {
      const result = [];
      for (let i = 0, len = response.length; i < len; i++) {
        const r = response[i];
        if (r.error) {
          this._handleException(r, true);
          continue;
        }
        const project = projects[i];
        project._rev = r.rev;
        project._id = r.id;
        this._fireUpdated('project-object-changed', {
          project: project
        });
        result[result.length] = r.id;
      }
      return result;
    });
  }
  /**
   * Saves a request into a data store.
   * It handles payload to string conversion, handles types, and syncs request
   * with projects. Use `update()` method only if you are storing already
   * prepared request object to the store.
   *
   * @param {Object} request ArcRequest object
   * @param {Object} opts Save request object. Currently only `isDrive`
   * is supported
   * @return {Promise} A promise resilved to updated request object.
   */
  saveRequest(request, opts) {
    opts = opts || {};
    if (!request.type) {
      if (request.name) {
        request.type = 'saved';
      } else {
        request.type = 'history';
      }
    } else if (request.type === 'drive' || request.type === 'google-drive') {
      request.type = 'saved';
    }
    if (!request._id) {
      request._id = this.uuid.generate();
    }
    return this._preparePayload(request)
    .then((result) => {
      request = result;
      return this._saveGoogleDrive(request, opts);
    })
    .then((request) => this.update(request.type, request))
    .then((request) => {
      return this._syncProjects(request._id, request.projects)
      .then(() => request);
    })
    .catch((cause) => this._handleException(cause));
  }
  /**
   * Sunchronizes project requests to ensure each project contains this
   * `requestId` on their list of requests.
   *
   * @param {String} requestId Request ID
   * @param {?Array<String>} projects List of request projects.
   * @return {Promise}
   */
  _syncProjects(requestId, projects) {
    if (!projects || !projects.length) {
      return Promise.resolve();
    }
    const db = this.projectDb;
    const update = [];
    return db.allDocs({
      // jscs:disable
      include_docs: true
      // jscs:enable
    })
    .then((response) => {
      const rows = response.rows;
      for (let i = 0, len = rows.length; i < len; i++) {
        const project = rows[i];
        const doc = project.doc;
        if (projects.indexOf(project.id) === -1) {
          const index = doc.requests ? doc.requests.indexOf(requestId) : -1;
          if (index !== -1) {
            doc.requests.splice(index, 1);
            update.push(doc);
          }
          continue;
        }
        if (!doc.requests) {
          doc.requests = [requestId];
          update.push(doc);
        } else if (doc.requests.indexOf(requestId) === -1) {
          doc.requests.push(requestId);
          update.push(doc);
        }
      }
      if (update.length) {
        return db.bulkDocs(update);
      }
    })
    .then((response) => {
      if (!response) {
        return;
      }
      for (let i = 0, len = response.length; i < len; i++) {
        const r = response[i];
        if (r.error) {
          this._handleException(r, true);
          continue;
        }
        const project = update[i];
        project._rev = r.rev;
        this._fireUpdated('project-object-changed', {
          project: project
        });
      }
    });
  }
  /**
   * Reads an entry from the datastore.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {String} id The ID of the datastore entry.
   * @param {?String} rev Specific revision to read. Defaults to
   * latest revision.
   * @return {Promise} Promise resolved to a project object.
   */
  read(type, id, rev) {
    const opts = {};
    if (rev) {
      opts.rev = rev;
    }
    const db = this.getDatabase(type);
    return db.get(id, opts);
  }
  /**
   * Updates / saves the request object in the datastore.
   * This function fires `request-object-changed` event.
   *
   * If any of `name`, `method`, `url` or `legacyProject` properties change
   * then the old object is deleted and new is created with new ID.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {Object} request An object to save / update
   * @return {Promise} Resolved promise to request object with updated `_rev`
   */
  update(type, request) {
    const db = this.getDatabase(type);
    let oldRev = request._rev;
    if (!request._id) {
      request._id = this.uuid.generate();
    }
    request.updated = Date.now();
    return db.put(request)
    .then((result) => {
      request._rev = result.rev;
      const detail = {
        request: request,
        oldRev: oldRev,
        oldId: request._id,
        type: type
      };
      this._fireUpdated('request-object-changed', detail);
      return request;
    });
  }
  /**
   * Updates more than one request in a bulk.
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {Array<Object>} requests List of requests to update.
   * @return {Array} List of PouchDB responses to each insert
   */
  updateBulk(type, requests) {
    const db = this.getDatabase(type);
    return db.bulkDocs(requests)
    .then((response) => {
      for (let i = 0, len = response.length; i < len; i++) {
        const r = response[i];
        if (r.error) {
          this._handleException(r, true);
          continue;
        }
        const request = requests[i];
        const oldRev = request._rev;
        request._rev = r.rev;
        const detail = {
          request,
          oldRev: oldRev,
          oldId: request._id,
          type: type
        };
        this._fireUpdated('request-object-changed', detail);
      }
      return response;
    });
  }
  /**
   * Removed an object from the datastore.
   * This function fires `request-object-deleted` event.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {String} id The ID of the datastore entry.
   * @param {?String} rev Specific revision to read. Defaults to
   * latest revision.
   * @return {Promise} Promise resolved to a new `_rev` property of deleted
   * object.
   */
  remove(type, id, rev) {
    let promise;
    if (!rev) {
      promise = this.read(type, id)
      .then((obj) => rev = obj._rev);
    } else {
      promise = Promise.resolve();
    }
    return promise.then(() => {
      const db = this.getDatabase(type);
      return db.remove(id, rev);
    })
    .then((response) => {
      const detail = {
        id: id,
        rev: response.rev,
        oldRev: rev,
        type: type
      };
      this._fireUpdated('request-object-deleted', detail);
      return response.rev;
    });
  }
  /**
   * Reverts deleted items.
   * This function fires `request-object-changed` event for each restored
   * request.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {Array} items List of request objects. Required properties are
   * `_id` and `_rev`.
   * @return {Promise} Resolved promise with restored objects. Objects have
   * updated `_rev` property.
   */
  revertRemove(type, items) {
    const db = this.getDatabase(type);
    // first get information about previous revision (before delete)
    return this._findNotDeleted(db, items)
    .then((restored) => {
      restored = restored.map((doc, i) => {
        doc._rev = items[i]._rev;
        return doc;
      });
      return db.bulkDocs(restored);
    })
    .then((result) => {
      return db.allDocs({
        keys: result.map((item) => item.id),
        // jscs:disable
        include_docs: true
        // jscs:enable
      });
    })
    .then((result) => {
      result.rows.forEach((request, i) => {
        const detail = {
          request: request.doc,
          oldRev: items[i]._rev,
          oldId: request.id,
          type: type
        };
        this._fireUpdated('request-object-changed', detail);
      });
      return result.rows;
    });
  }
  /**
   * Finds last not deleted revision of a document.
   * @param {Object} db PouchDB instance
   * @param {Array} items List of documents to process
   * @return {Promise<Array>} Last not deleted version of each document.
   */
  _findNotDeleted(db, items) {
    const list = items.map((item) => {
      return {
        id: item._id,
        rev: item._rev
      };
    });
    const options = {
      docs: list,
      revs: true
    };
    return db.bulkGet(options)
    .then((result) => {
      return result.results.map((item, i) => {
        const doc = item.docs[0].ok;
        const revs = doc._revisions;
        const undeletedRevision =
          this._findUndeletedRevision(revs, items[i]._rev);
        if (!undeletedRevision) {
          throw new Error('Previous version of the object not found');
        }
        return db.get(doc._id, {rev: undeletedRevision});
      });
    })
    .then((promises) => Promise.all(promises));
  }
  /**
   * Finds a next revision after the `deletedRevision` in the revisions history
   * which is the one that reverts any changes made after it.
   *
   * @param {Object} revs PouchDB revision history object
   * @param {Object} deletedRevision Revision of deleted object (after delete).
   * @return {String} Revision ID of the object before a change registered in
   * `deletedRevision`
   */
  _findUndeletedRevision(revs, deletedRevision) {
    // find a revision matching deleted item's updated rev
    let index = revs.start;
    const ids = revs.ids;
    let found = false;
    for (let i = 0, len = ids.length; i < len; i++) {
      const revision = index + '-' + ids[i];
      if (found) {
        return revision;
      }
      if (revision === deletedRevision) {
        // next revision is the one we are looking for.
        found = true;
      }
      index--;
    }
  }
  /**
   * Handler for request read event request.
   * @param {CustomEvent} e
   */
  _handleRead(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.id) {
      e.detail.result = Promise.reject(
        new Error('Request "id" property is missing.'));
      return;
    }
    if (!e.detail.type) {
      e.detail.result = Promise.reject(
        new Error('Request "type" property is missing.'));
      return;
    }
    e.detail.result = this.read(e.detail.type, e.detail.id, e.detail.rev)
    .catch((e) => this._handleException(e));
  }

  /**
   * Updates name of a request.
   *
   * @deprecated This function will be removed. Use `update()` instead.
   * @param {CustomEvent} e
   */
  _handleNameChange(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.name) {
      e.detail.result = Promise.reject(
        new Error('The "name" property is missing'));
      return;
    }
    const missingMsg = 'Either "request" object or request "id" must be set.';
    if (!e.detail.request && !e.detail.id) {
      e.detail.result = Promise.reject(new Error(missingMsg));
      return;
    }
    const request = e.detail.request;
    let promise;
    if (request && request._id && request._rev) {
      promise = Promise.resolve(request);
    } else {
      if (!e.detail.id) {
        e.detail.result = Promise.reject(new Error(missingMsg));
        return;
      }
      promise = this.read('saved', e.detail.id);
    }

    e.detail.result = promise
    .then((obj) => {
      obj = Object.assign({}, obj);
      obj.name = e.detail.name;
      return this.update('saved', obj);
    })
    .catch((e) => this._handleException(e));
  }
  /**
   * Handles onject save / update
   *
   * @param {CustomEvent} e
   */
  _handleObjectSave(e) {
    if (!e.cancelable) {
      return;
    }
    if (e.composedPath()[0] === this) {
      this._indexRequest(e.detail.request);
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    const request = e.detail.request;
    if (!request) {
      e.detail.result = Promise.reject(
        new Error('The "request" property is missing.'));
      return;
    }
    if (!e.detail.type) {
      e.detail.result = Promise.reject(
        new Error('The "type" property is missing.'));
      return;
    }
    const db = this.getDatabase(e.detail.type);
    let p;
    if (request._id && !request._rev) {
      p = db.get(request._id)
      .catch((e) => {
        if (e.status === 404) {
          // create new
          return {};
        }
        this._handleException(e);
      });
    } else {
      p = Promise.resolve({});
    }
    e.detail.result = p
    .then((result) => {
      result = Object.assign({}, result, request);
      return this.update(e.detail.type, result);
    })
    .catch((e) => this._handleException(e));
  }
  /**
   * Deletes the object from the datastore.
   *
   * @param {CustomEvent} e
   */
  _handleObjectDelete(e) {
    if (!e.cancelable) {
      return;
    }
    if (e.composedPath()[0] === this) {
      this._deleteIndex(e.detail.id);
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.type) {
      e.detail.result = Promise.reject(
        new Error('Request "type" property is missing.'));
      return;
    }

    if (!e.detail.id) {
      e.detail.result = Promise.reject(new Error('Missing "id" property.'));
      return;
    }

    e.detail.result = this.remove(e.detail.type, e.detail.id, e.detail.rev)
    .catch((e) => this._handleException(e));
  }
  /**
   * Queries for a list of projects.
   * @param {CustomEvent} e
   */
  _handleObjectsDelete(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.type) {
      e.detail.result = Promise.reject(
        new Error('Request "type" property is missing.'));
      return;
    }

    if (!e.detail.items) {
      e.detail.result = Promise.reject(
        new Error('The "items" property is missing.'));
      return;
    }
    const db = this.getDatabase(e.detail.type);
    let removed = [];
    e.detail.result = db.allDocs({
      keys: e.detail.items
    })
    .then((res) => this._filterExistingItems(res))
    .then((res) => {
      removed = res;
      return Promise.all(res.map((i) => db.remove(i.id, i.value.rev)));
    })
    .then((result) => {
      const data = {};
      result.forEach((item) => {
        if (item.ok) {
          const detail = {
            id: item.id,
            rev: item.rev,
            oldRev: this._findOldRef(removed, item.id)
          };
          data[item.id] = item.rev;
          this._fireUpdated('request-object-deleted', detail);
        }
      });
      return data;
    });
  }
  /**
   * handlers `request-objects-undeleted` event to restore deleted items
   * @param {CustomEvent} e
   */
  _handleObjectsUndelete(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.type) {
      e.detail.result = Promise.reject(
        new Error('Request "type" property is missing.'));
      return;
    }

    if (!e.detail.items) {
      e.detail.result = Promise.reject(
        new Error('The "items" property is missing.'));
      return;
    }
    e.detail.result = this.revertRemove(e.detail.type, e.detail.items)
    .catch((e) => this._handleException(e));
  }
  /**
   * Filters query results to return only successfuly read data.
   * @param {Object} result PouchDB query result
   * @return {Array} List of request that has been read.
   */
  _filterExistingItems(result) {
    result = result.rows.filter((item) => {
      if (item.error) {
        console.error(item);
        return false;
      }
      return true;
    });
    return result;
  }
  /**
   * Finds a `_rev` for a doc.
   * @param {Array} docs List of PouchDB documents to search for `_rev`
   * @param {String} id Document ID
   * @return {String} Associated `_rev`
   */
  _findOldRef(docs, id) {
    const result = docs.find((item) => item._id === id);
    return result ? result._rev : undefined;
  }

  /**
   * Saves the request on Google Drive.
   * It sends `drive-request-save` event to call a component responsible
   * for saving the request.
   *
   * This do nothing if `opts.drive is not set.`
   *
   * @param {Object} data Data to save
   * @param {Object} opts Save request options. See `saveRequest` for more info.
   * @return {Promise} Resolved promise to updated object.
   */
  _saveGoogleDrive(data, opts) {
    if (!opts.isDrive) {
      return Promise.resolve(data);
    }
    const copy = Object.assign({}, data);
    const e = new CustomEvent('export-google-drive', {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: {
        content: copy,
        contentType: 'application/json',
        file: copy.name + '.arc'
      }
    });
    this.dispatchEvent(e);
    if (!e.defaultPrevented) {
      console.warn('Unable to export request to Google Drive.');
      console.warn('The drive-request-save was not handled.');
      return Promise.reject(new Error('Drive export module not found'));
    }
    return e.detail.result
    .then((insertResult) => {
      const driveId = insertResult.id;
      if (driveId) {
        data.driveId = driveId;
      }
      return data;
    });
  }
  /**
   * Prepares payload data to be stored in the datastore.
   * FormData are translated to a `multipart` entry property.
   * Payload is cleared from the request object.
   *
   * @param {Object} data The request object.
   * @return {Promise} Promise resolved to a request object.
   */
  _preparePayload(data) {
    if (!data.payload) {
      return Promise.resolve(data);
    }
    if (data.payload instanceof FormData) {
      data = Object.assign({}, data);
      if (!data.payload.entries) {
        data.payload = undefined;
        return Promise.resolve(data);
      }
      return this._createMultipartEntry(data.payload)
      .then((entry) => {
        data.payload = undefined;
        data.multipart = entry;
        return data;
      });
    } else if (data.payload instanceof Blob) {
      data = Object.assign({}, data);
      return this._blobToString(data.payload)
      .then((str) => {
        data.payload = undefined;
        data.blob = str;
        return data;
      });
    }
    return Promise.resolve(data);
  }
  /**
   * Computes `multipart` list value to replace FormData with array that can
   * be stored in the datastore.
   *
   * @param {FormData} payload FormData object
   * @return {Promise} Promise resolved to a form part representation.
   */
  _createMultipartEntry(payload) {
    const iterator = payload.entries();
    let textParts;
    if (payload._arcMeta && payload._arcMeta.textParts) {
      textParts = payload._arcMeta.textParts;
    }
    return this._computeFormDataEntry(iterator, textParts);
  }
  /**
   * Recuresively iterates over form data and appends result of creating the
   * part object to the `result` array.
   *
   * Each part entry contains `name` as a form part name, value as a string
   * representation of the value and `isFile` to determine is the value is
   * acttually a string or a file data.
   *
   * @param {Iterator} iterator FormData iterator
   * @param {?Array<String>} textParts From `_arcMeta` property. List of blobs
   * that should be treated as text parts.
   * @param {?Array<Object>} result An array where the results are appended to.
   * It creates new result object when it's not passed.
   * @return {Promise} A promise resolved to the `result` array.
   */
  _computeFormDataEntry(iterator, textParts, result) {
    result = result || [];
    const item = iterator.next();
    if (item.done) {
      return Promise.resolve(result);
    }
    let entry = item.value;
    let name = entry[0];
    let value = entry[1];
    let promise;
    let isBlob = false;
    let isTextBlob = false;
    if (value instanceof Blob) {
      promise = this._blobToString(value);
      if (textParts && textParts.indexOf(name) !== -1) {
        isBlob = false;
        isTextBlob = true;
      } else {
        isBlob = true;
      }
    } else {
      promise = Promise.resolve(value);
    }
    return promise
    .then((str) => {
      const _part = {
        name: name,
        value: str,
        isFile: isBlob
      };
      if (isTextBlob) {
        _part.isTextBlob = isTextBlob;
      }
      return _part;
    })
    .then((part) => {
      result.push(part);
      return this._computeFormDataEntry(iterator, textParts, result);
    });
  }
  /**
   * Converts blob data to base64 string.
   *
   * @param {Blob} blob File or blob object to be translated to string
   * @return {Promise} Promise resolved to a base64 string data from the file.
   */
  _blobToString(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = function(e) {
        resolve(e.target.result);
      };
      reader.onerror = function() {
        reject(new Error('Unable to convert blob to string.'));
      };
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Updates or creates request search index used when querying for request
   * data.
   *
   * This operation is async and in a web worker (separate thred).
   *
   * @param {Object} request A request to index.
   */
  _indexRequest(request) {
    if (this.noIndexing) {
      return;
    }
    if (!this.__indexRequestQueue) {
      this.__indexRequestQueue = [];
    }
    this.__indexRequestQueue.push(request);
    if (this.__indexRequestDebounce) {
      return;
    }
    this.__indexRequestDebounce = true;
    setTimeout(() => {
      const worker = this._getIndexWorker();
      const requests = this.__indexRequestQueue;
      this.__indexRequestQueue = [];
      this.__indexRequestDebounce = false;
      worker.postMessage({
        task: 'index-requests',
        requests: requests.map((item) => {
          let type = item.type;
          if (type === 'saved-requests') {
            type = 'saved';
          } else if (type === 'history-requests') {
            type = 'history';
          }
          return {
            id: item._id,
            url: item.url,
            type: type
          };
        })
      });
    }, 250);
  }
  /**
   * Removed URL index data when the request is deleted.
   * @param {String} id Request IDs to delete.
   */
  _deleteIndex(id) {
    if (this.noIndexing) {
      return;
    }
    if (!this.__indexDeleteQueue) {
      this.__indexDeleteQueue = [];
    }
    this.__indexDeleteQueue.push(id);
    if (this.__indexDeleteDebounce) {
      return;
    }
    this.__indexDeleteDebounce = true;
    setTimeout(() => {
      const worker = this._getIndexWorker();
      const ids = this.__indexDeleteQueue;
      this.__indexDeleteQueue = [];
      this.__indexDeleteDebounce = false;
      worker.postMessage({
        task: 'delete-index',
        ids
      });
    }, 250);
  }
  /**
   * Creates if nescesary and returns indexing web worker.
   * @return {Worker} An indexing web worker instance.
   */
  _getIndexWorker() {
    if (this._indexWorker) {
      return this._indexWorker;
    }
    const worker = new Worker(this.resolveUrl('../arc-models/workers/request-indexer.js'));
    worker.addEventListener('message', this._onIndexWorkerData);
    worker.addEventListener('error', this._onIndexWorkerError);
    this._indexWorker = worker;
    return worker;
  }

  /**
   * Terminates the worker (if exists) and removes event listeners
   */
  _unregisterWorker() {
    if (!this._indexWorker) {
      return;
    }
    this._indexWorker.removeEventListener('message', this._onIndexWorkerData);
    this._indexWorker.removeEventListener('error', this._onIndexWorkerError);
    this._indexWorker.terminate();
    delete this._indexWorker;
  }
  /**
   * A handler for data returned from the request indexing worker.
   *
   * @param {Event} e Worker event
   */
  _onIndexWorkerData(e) {
    const data = e.data;
    switch (data.task) {
      case 'task-finished':
        this.dispatchEvent(new CustomEvent('request-indexing-finished', {
          composed: true
        }));
        break;
      case 'query-finished':
        this._urlQueryHandler(data.id, data.results);
        break;
      case 'task-error':
        this.dispatchEvent(new CustomEvent('request-indexing-error', {
          composed: true,
          detail: {
            message: data.message
          }
        }));
        this._handleException(new Error(data.message), true);
        if (data.id) {
          const callbacks = this._workerPromises[data.id];
          delete this._workerPromises[data.id];
          callbacks.reject(new Error(data.message));
        }
        break;
    }
  }
  /**
   * A handler for error returned from the request indexing worker.
   *
   * @param {Event} e Worker event
   */
  _onIndexWorkerError(e) {
    console.error(e);
    this.dispatchEvent(new CustomEvent('request-indexing-error', {
      composed: true,
      detail: {
        message: e.message || 'Indexing worker error'
      }
    }));
  }
  /**
   * A handler for the `request-query` custom event. Queries the datastore for
   * request data.
   * The event must have `q` property set on the detail object.
   *
   * @param {CustomEvent} e
   */
  _handleQuery(e) {
    if (!e.cancelable) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.q) {
      e.detail.result = Promise.reject(
        new Error('The "q" property is missing.'));
      return;
    }
    e.detail.result = this.queryUrlData(e.detail.q, e.detail.type, e.detail.detailed)
    .then((urlSearechResults) => {
      const ignore = urlSearechResults.map((item) => item._id);
      return this.query(e.detail.q, e.detail.type, ignore)
      .then((result) => urlSearechResults.concat(result));
    });
  }
  /**
   * Performs a query on the URL index data.
   *
   * @param {String} q User query
   * @param {?String} type Optional, type of the requests to search for.
   * By default it returns all data.
   * @param {?Boolean} detailed If set it uses slower algorithm but performs full
   * search on the index. When false it only uses filer like query + '*'.
   * @return {Promise<Array<Object>>} Promise resolved to the list of requests.
   */
  queryUrlData(q, type, detailed) {
    return new Promise((resolve, reject) => {
      const reqId = ++this._workerRequestId;
      this._workerPromises[reqId] = {
        resolve,
        reject
      };
      const worker = this._getIndexWorker();
      worker.postMessage({
        task: 'query-data',
        id: reqId,
        type,
        q,
        detailed
      });
    });
  }
  /**
   * Handler for URL index results search.
   *
   * @param {String} id The ID sent to the web worker to identify callback
   * function.
   * @param {Object} results Map of request id - request type.
   * @return {Promise}
   */
  _urlQueryHandler(id, results) {
    const callbacks = this._workerPromises[id];
    delete this._workerPromises[id];
    const keys = Object.keys(results);
    if (!keys.length) {
      callbacks.resolve(results);
      return;
    }
    const savedKeys = [];
    const historyKeys = [];
    for (let i = 0, len = keys.length; i < len; i++) {
      if (results[keys[i]] === 'history') {
        historyKeys[historyKeys.length] = keys[i];
      } else {
        savedKeys[savedKeys.length] = keys[i];
      }
    }
    const p = [];
    if (savedKeys.length) {
      p[p.length] = this.savedDb.allDocs({
        keys: savedKeys,
        // jscs:disable
        include_docs: true
        // jscs:enable
      });
    }
    if (historyKeys.length) {
      p[p.length] = this.historyDb.allDocs({
        keys: historyKeys,
        // jscs:disable
        include_docs: true
        // jscs:enable
      });
    }
    return Promise.all(p)
    .then((results) => {
      const data = [];
      for (let i = 0, iLen = results.length; i < iLen; i++) {
        const response = results[i];
        for (let j = 0, jLen = response.rows.length; j < jLen; j++) {
          if (response.rows[j].error) {
            continue;
          }
          data[data.length] = response.rows[j].doc;
        }
      }
      callbacks.resolve(data);
      // This is for tests
      return data;
    });
  }
  /**
   * Performs a query on the request data store.
   * It uses PouchDB `query` function on built indexes.
   * Note, it does not query URL data.
   *
   * @param {String} q User query
   * @param {?String} type Optional, type of the requests to search for.
   * By default it returns all data for both history and saved.
   * @param {?Array<String>} ignore List of IDs to ignore.
   * @return {Promise<Array<Object>>} Promise resolved to the list of requests.
   */
  query(q, type, ignore) {
    if (!q) {
      return Promise.reject('The "q" parameter is required.');
    }
    if (type === 'history') {
      return this.queryHistory(q, ignore);
    }
    if (type === 'saved') {
      return this.querySaved(q, ignore);
    }
    return Promise.all([this.queryHistory(q, ignore), this.querySaved(q, ignore)])
    .then((results) => results[0].concat(results[1]));
  }
  /**
   * List of fields to index in the history store.
   * @return {Array<String>}
   */
  get historyIndexes() {
    return ['headers', 'payload', 'method'];
  }
  /**
   * List of fields to index in the saved store.
   * @return {Array<String>}
   */
  get savedIndexes() {
    return ['headers', 'payload', 'method', 'description', 'name'];
  }
  /**
   * Queries history store using PouchDB quick search plugin (full text search).
   *
   * @param {String} q User query
   * @param {?Array<String>} ignore List of IDs to ignore.
   * @return {Promise<Array<Object>>} Promise resolved to the list of requests.
   */
  queryHistory(q, ignore) {
    return this._queryStore(q, ignore, this.historyDb, this.historyIndexes);
  }
  /**
   * Queries Saved store using PouchDB quick search plugin (full text search).
   *
   * @param {String} q User query
   * @param {?Array<String>} ignore List of IDs to ignore.
   * @return {Promise<Array<Object>>} Promise resolved to the list of requests.
   */
  querySaved(q, ignore) {
    return this._queryStore(q, ignore, this.savedDb, this.savedIndexes);
  }

  _queryStore(q, ignore, db, indexes) {
    if (!q) {
      return Promise.reject('The "q" parameter is required.');
    }
    if (ignore !== undefined && !(ignore instanceof Array)) {
      return Promise.reject('The "ignore" parameter must be an array.');
    }
    q = String(q);
    return db.search({
      query: q,
      fields: indexes,
      // jscs:disable
      include_docs: true,
      // jscs:enable
      mm: (100 / q.split(' ').length)
    })
    .then((data) => {
      const rows = data.rows || [];
      const result = [];
      for (let i = rows.length - 1; i >= 0; i--) {
        if (!(ignore && ignore.indexOf(data[i].id) !== -1)) {
          result[result.length] = data[i].doc;
        }
      }
      return result;
    });
  }
  /**
   * Performs data index using PouchDB api.
   *
   * @param {String} type Data type - saved or history.
   * @return {Promise}
   */
  indexData(type) {
    const db = type === 'history' ? this.historyDb : this.savedDb;
    return db.search({
      fields: ['title', 'text'],
      build: true
    });
  }
  /**
   * Fired when the request should be expored to Google Drive.
   * This element doesn't support this operation but this way it queries for
   * an element that can export data to Google Drive.
   *
   * @event drive-request-save
   * @param {Object} request Request data to export
   * @param {String} fileName Google Drive file name.
   */

  /**
   * Fired when the project entity has been saved / updated in the datastore.
   *
   * @event request-object-changed
   * @param {Object} request Request object with new `_rev`.
   * @param {String} oldRev Entity old `_rev` property. May be `undefined` when
   * creating new entity.
   * @param {String} oldId Entity old `_id` property. May be `undefined` when
   * creating new entity.
   * @param {String} type Request object type. Can be either `saved-requests` or
   * `history-requests`
   */

  /**
   * @event request-object-deleted
   * @param {String} id Removed request ID
   * @param {String} rev Updated `_rev` property of the object.
   * @param {String} oldRev Entity old `_rev` property (before delete).
   * @param {String} type Request object type. Can be either `saved-requests` or
   * `history-requests`
   */

  /**
   * Dispatched when request object indexing finishes.
   * This event does not bubbles.
   *
   * @event request-indexing-finished
   */
  /**
   * Dispatched when request object indexing finishes with error.
   * This event does not bubbles.
   *
   * @event request-indexing-error
   * @param {String} message Error message
   */

  /**
   * Dispatched when saving request object to the data store and configuration
   * option says to save request to Google Drive.
   * This component does not handles the logic responsible for Drive integration.
   *
   * Note, The request save flow fails when this event is not handled.
   *
   * @event export-google-drive
   * @param {Object} content Data to store in the Drive
   * @param {String} contentType Always 'application/json'
   * @param {String} file Drive file name
   */
}
window.customElements.define(RequestModel.is, RequestModel);
</script>
