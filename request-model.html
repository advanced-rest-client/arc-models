<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="base-model.html">
<script>
/**
 * Events based access to saved request datastore.
 *
 * Note: **All events must be cancelable.** When the event is cancelled by an instance
 * of the element it won't be handled again by other instance that possibly exists
 * in the DOM.
 *
 * Cancellable event is a request to models for change. Non-cancellable event
 * is a notification for views to update their values. For example
 * `request-object-changed` event notifies model to update object in
 * the datastore if the event is cancelable and to update views if it's not
 * cancellable.
 *
 * Each handled event contains the `result` property on the `detail` object. It
 * contains a `Promise` object with a result of the operation. Also, for update / delete
 * events the same non-cancelable event is fired.
 *
 * Events handled by this element are cancelled and propagation of the event is
 * stopped.
 *
 * Supported operations:
 *
 * -   Read request object (`request-object-read`)
 * -   Update name only (`request-name-changed`)
 * -   Update request object (`request-object-changed`)
 * -   Delete object (`request-object-deleted`)
 * -   Deletes list of request objects (`request-objects-deleted`)
 *
 * ## Request object types
 *
 * There are two request object types: `saved-requests` and `history-requests`.
 * Each event must contain a `type` property to determine which database to query
 * for an object.
 *
 * ### Events description
 *
 * #### `request-object-read` event
 *
 * Reads a request object from the datastore.
 *
 * ##### Properties
 *
 * -   `id` (String, required) ID of the datastore entry
 * -   `rev` (String, optional) Specific revision to retrieve from the
 * datastore. Latest by default.
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-object-read', {
 *    detail: { id: 'some-id', type: 'saved-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(request => console.log(request));
 * }
 * ```
 *
 * #### `request-name-changed` Event
 *
 * Changes name of a request. Promise result has updated `name` and `_rev` properties.
 * This operation deletes old object because it changes the `name` of the request
 * that is used to build the datastore key.
 *
 * ##### Properties
 * -   `id` (String, required if `project` is not set) ID of the datastore entry
 * -   `request` (Object, required if `id` is not set) The database entity
 * -   `name` (String, required) New name of the project. It doesn't matter
 * if `project` property already has new name.
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-name-changed', {
 *    detail: { id: 'some-id', name: 'new name', type: 'history-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(request => console.log(request));
 * }
 * ```
 *
 * #### `request-object-changed` event
 *
 * Updates / saves new object in the datastore.
 *
 * ##### Properties
 *
 * -   `request` (Object, required) An object to store
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 **
 * ```javascript
 * var event = new CustomEvent('request-object-changed', {
 *    detail: { request: {...}, type: 'saved-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(request => console.log(request));
 * }
 * ```
 *
 * #### `request-object-deleted` event
 *
 * Deletes the object from the datastore. This operation fires `request-object-deleted`
 * custom event. Promise returns object's new `_rev` value.
 *
 * ##### Properties
 * -   `id` (String, required) ID of the datastore entry
 * -   `rev` (String, optional) The `_rev` property of the PouchDB datastore
 * object. If not set it will use latest revision.
 * -   `type` {String, required} Request object type. Either `saved-requests` or
 * `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-object-deleted', {
 *    detail: { id: 'some-id', type: 'saved-requests' },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(newRev => console.log(newRev));
 * }
 * ```
 *
 * #### `request-objects-deleted` event
 *
 * Removes list of requests in batch operation. Promise results to the map where keys
 * are request ids and values are new revision hash.
 *
 * ##### Properties
 *
 * -   `items` (Array, required) List of IDs to delete
 * -   `type` {String, required} Request object type. Either `saved-requests` or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-objects-deleted', {
 *    detail: {
 *      items: ['some-id', 'other-id'],
 *      type: 'saved-requests'
 *    },
 *    bubbles: true,
 *    composed: true,
 *    cancelable: true
 *  });
 *  if (event.defaultPrevented) {
 *    event.detail.result.then(deleted => console.log(deleted));
 *  }
 *  ```<link rel="import" href="../polymer/polymer.html">
 *  <link rel="import" href="../app-pouchdb/pouchdb.html">
 *  <link rel="import" href="../events-target-behavior/events-target-behavior.html">
 *
 * #### `request-objects-undeleted` event
 *
 * Restores previously deleted requests from the history.
 * It searches in the revision history of each object to find a revision before
 * passed `_rev` and restores this object as a new one in the revision tree.
 *
 * This operation fires `request-object-deleted` custom event. Promise returns
 * request objects with updated `_rev` value.
 *
 * ##### Properties
 *
 * -   `items` (Array, required) List of requests to restore. It required `_id`
 * and `_rev` properties to be set on each object. The `_rev` property must be
 * a revision updated after the deletion of the object.
 * -   `type` {String, required} Request object type. Either `saved-requests`
 * or `history-requests`
 *
 * ##### Example
 *
 * ```javascript
 * var event = new CustomEvent('request-objects-deleted', {
 *    detail: {
 *      items: [{_id: 'some-id', '_rev': '2-xyz']},
 *      type: 'saved-requests'
 *    },
 *    bubbles: true,<link rel="import" href="../polymer/polymer.html">
 * <link rel="import" href="../app-pouchdb/pouchdb.html">
 * <link rel="import" href="../events-target-behavior/events-target-behavior.html">
 *    composed: true,
 *    cancelable: true
 * });
 * if (event.defaultPrevented) {
 *    event.detail.result.then(restored => console.log(restored));
 * }
 * ```
 *
 * @polymer
 * @customElement
 * @memberof LogicElements
 */
class RequestModel extends ArcBaseModel {
  static get is() { return 'request-model'; };

  constructor() {
    super();
    this._handleRead = this._handleRead.bind(this);
    this._handleNameChange = this._handleNameChange.bind(this);
    this._handleObjectSave = this._handleObjectSave.bind(this);
    this._handleObjectDelete = this._handleObjectDelete.bind(this);
    this._handleObjectsDelete = this._handleObjectsDelete.bind(this);
    this._handleObjectsUndelete = this._handleObjectsUndelete.bind(this);
  }

  _attachListeners(node) {
    node.addEventListener('request-object-read', this._handleRead);
    node.addEventListener('request-name-changed', this._handleNameChange);
    node.addEventListener('request-object-changed', this._handleObjectSave);
    node.addEventListener('request-object-deleted', this._handleObjectDelete);
    node.addEventListener('request-objects-deleted', this._handleObjectsDelete);
    node.addEventListener('request-objects-undeleted', this._handleObjectsUndelete);
  }

  _detachListeners(node) {
    node.removeEventListener('request-object-read', this._handleRead);
    node.removeEventListener('request-name-changed', this._handleNameChange);
    node.removeEventListener('request-object-changed', this._handleObjectSave);
    node.removeEventListener('request-object-deleted', this._handleObjectDelete);
    node.removeEventListener('request-objects-deleted', this._handleObjectsDelete);
    node.removeEventListener('request-objects-undeleted', this._handleObjectsUndelete);
  }

  get savedDb() {
    return new PouchDB('saved-requests');
  }

  get historyDb() {
    return new PouchDB('history-requests');
  }
  /**
   * Returns a reference to a PouchDB database instance for given type.
   *
   * @param {String} type Either `saved-requests` or `history-requests`
   * @return {PouchDB} PouchDB instance for the datastore.
   */
  getDatabase(type) {
    switch (type) {
      case 'saved-requests': return this.savedDb;
      case 'history-requests': return this.historyDb;
      default: throw new Error('Unknown database type');
    }
  }
  /**
   * Reads an entry from the datastore.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {String} id The ID of the datastore entry.
   * @param {?String} rev Specific revision to read. Defaults to latest revision.
   * @return {Promise} Promise resolved to a project object.
   */
  read(type, id, rev) {
    const opts = {};
    if (rev) {
      opts.rev = rev;
    }
    const db = this.getDatabase(type);
    return db.get(id, opts);
  }
  /**
   * Updates / saves the request object in the datastore.
   * This function fires `request-object-changed` event.
   *
   * If any of `name`, `method`, `url` or `legacyProject` properties change
   * then the old object is deleted and new is created with new ID.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {Object} request An object to save / update
   * @return {Promise} Resolved promise to request object with updated `_rev`
   */
  update(type, request) {
    const db = this.getDatabase(type);
    let promise;
    let oldRev = request._rev;
    let oldId = request._id;
    let regenerateId = false;
    const isHistory = type === 'history-requests';
    if (request._id) {
      // Checks if the ID has to be regenerated if parts of the ID changes.
      promise = this.read(type, request._id, request._rev)
      .then((req) => {
        oldId = req._id;
        oldRev = request._rev = req._rev;
        if (!isHistory && request.name !== req.name) {
          regenerateId = true;
        }
        if (!isHistory && request.legacyProject !== req.legacyProject) {
          regenerateId = true;
        }
        if (request.url !== req.url) {
          regenerateId = true;
        }
        if (request.method !== req.method) {
          regenerateId = true;
        }
      });
    } else {
      promise = Promise.resolve();
    }

    return promise
    .then(() => {
      if (regenerateId) {
        const removeId = request._id;
        const removeRev = request._rev;
        request._id = this._generateId(request, isHistory);
        delete request._rev;
        return db.remove(removeId, removeRev);
      } else if (!request._id) {
        request._id = this._generateId(request, isHistory);
      }
    })
    .then(() => {
      request.updated = Date.now();
      return db.put(request);
    })
    .then((result) => {
      request._rev = result.rev;
      const detail = {
        request: request,
        oldRev: oldRev,
        oldId: oldId,
        type: type
      };
      this._fireUpdated('request-object-changed', detail);
      return request;
    });
  }
  /**
   * Updates more than one request in a bulk.
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {Array} request List of requests to update.
   * @return {Array} List of PouchDB responses to each insert
   */
  updateBulk(type, requests) {
    const promises = requests.map((item) => {
      const options = {
        oldRev: item._rev,
        oldId: item._id,
        regenerateId: false,
        isHistory: type === 'history-requests',
        request: item
      };
      if (item._id) {
        return this.read(type, item._id, item._rev)
        .then((req) => {
          options.oldId = req._id;
          options.oldRev = options.request._rev = req._rev;
          if (!options.isHistory && item.name !== req.name) {
            options.regenerateId = true;
          } else if (!options.isHistory && item.legacyProject !== req.legacyProject) {
            options.regenerateId = true;
          } else if (item.url !== req.url) {
            options.regenerateId = true;
          } else if (item.method !== req.method) {
            options.regenerateId = true;
          }
          return options;
        });
      } else {
        return Promise.resolve(options);
      }
    });
    const db = this.getDatabase(type);
    const toInsert = [];
    return Promise.all(promises)
    .then((list) => {
      const toRemove = [];
      list.forEach((item) => {
        if (item.regenerateId) {
          const clone = Object.assign({}, item.request);
          clone._deleted = true;
          toRemove.push(clone);
          item.request._id = this._generateId(item.request, item.isHistory);
          delete item.request._rev;
        } else if (!item.request._id) {
          item.request._id = this._generateId(item.request, item.isHistory);
        }
        item.request.updated = Date.now();
        toInsert.push(item);
      });
      if (toRemove.length) {
        return db.bulkDocs(toRemove)
        .then((response) => {
          response.forEach((item, index) => {
            const detail = {
              id: item.id,
              rev: item.rev,
              oldRev: toRemove[index]._rev,
              type: type
            };
            this._fireUpdated('request-object-deleted', detail);
          });
        });
      }
    })
    .then(() => db.bulkDocs(toInsert.map((item) => item.request)))
    .then((response) => {
      response.forEach((item, index) => {
        if (!item.ok) {
          console.warn('Update error', item);
          return;
        }
        const options = toInsert[index];
        const request = options.request;
        request._rev = item.rev;
        const detail = {
          request: request,
          oldRev: options.oldRev,
          oldId: options.oldId,
          type: type
        };
        this._fireUpdated('request-object-changed', detail);
      });
      return response;
    });
  }
  /**
   * Removed an object from the datastore.
   * This function fires `request-object-deleted` event.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {String} id The ID of the datastore entry.
   * @param {?String} rev Specific revision to read. Defaults to latest revision.
   * @return {Promise} Promise resolved to a new `_rev` property of deleted object.
   */
  remove(type, id, rev) {
    let promise;
    if (!rev) {
      promise = this.read(type, id)
      .then((obj) => rev = obj._rev);
    } else {
      promise = Promise.resolve();
    }
    return promise.then(() => {
      const db = this.getDatabase(type);
      return db.remove(id, rev);
    })
    .then(response => {
      const detail = {
        id: id,
        rev: response.rev,
        oldRev: rev,
        type: type
      };
      this._fireUpdated('request-object-deleted', detail);
      return response.rev;
    });
  }
  /**
   * Reverts deleted items.
   * This function fires `request-object-changed` event for each restored
   * request.
   *
   * @param {String} type Request type: `saved-requests` or `history-requests`
   * @param {Array} items List of request objects. Required properties are
   * `_id` and `_rev`.
   * @return {Promise} Resolved promise with restored objects. Objects have
   * updated `_rev` property.
   */
  revertRemove(type, items) {
    const db = this.getDatabase(type);
    // first get information about previous revision (before delete)
    return this._findNotDeleted(db, items)
    .then((restored) => {
      restored = restored.map((doc, i) => {
        doc._rev = items[i]._rev;
        return doc;
      });
      return db.bulkDocs(restored);
    })
    .then((result) => {
      return db.allDocs({
        keys: result.map(item => item.id),
        // jscs:disable
        include_docs: true
        // jscs:enable
      });
    })
    .then((result) => {
      result.rows.forEach((request, i) => {
        const detail = {
          request: request.doc,
          oldRev: items[i]._rev,
          oldId: request.id,
          type: type
        };
        this._fireUpdated('request-object-changed', detail);
      });
      return result.rows;
    });
  }

  _findNotDeleted(db, items) {
    const list = items.map((item) => {
      return {
        id: item._id,
        rev: item._rev
      };
    });
    const options = {
      docs: list,
      revs: true
    };
    return db.bulkGet(options)
    .then((result) => {
      return result.results.map((item, i) => {
        const doc = item.docs[0].ok;
        const revs = doc._revisions;
        const undeletedRevision = this._findUndeletedRevision(revs, items[i]._rev);
        if (!undeletedRevision) {
          throw new Error('Previous version of the object not found');
        }
        return db.get(doc._id, {rev: undeletedRevision});
      });
    })
    .then((promises) => Promise.all(promises));
  }
  /**
   * Finds a next revision after the `deletedRevision` in the revisions history
   * which is the one that reverts any changes made after it.
   *
   * @param {Object} revs PouchDB revision history object
   * @param {Object} deletedRevision Revision of deleted object (after delete).
   * @return {String} Revision ID of the object before a change registered in
   * `deletedRevision`
   */
  _findUndeletedRevision(revs, deletedRevision) {
    // find a revision matching deleted item's updated rev
    const index = revs.start;
    const ids = revs.ids;
    let found = false;
    for (let i = 0, len = ids.length; i < len; i++) {
      const revision = index + '-' + ids[i];
      if (found) {
        return revision;
      }
      if (revision === deletedRevision) {
        // next revision is the one we are looking for.
        found = true;
      }
      index--;
    }
  }
  /**
   * Generates the IS for the request depending on it's type and properties.
   *
   * @param {Object} request The request object to store.
   * @param {Boolean} isHistory Is true then it generates an ID for a history
   * item
   * @return {String} A database ID
   */
  _generateId(request, isHistory) {
    let id;
    if (isHistory) {
      let time = request.updated || request.created;
      time = Number(time);
      if (time !== time) {
        time = request.updated = request.created = Date.now();
      }
      id = this._getDayToday(time);
    } else {
      request.name = request.name || '';
      const name = request.name.toLowerCase();
      id = encodeURIComponent(name);
    }
    id += '/';
    let url = request.url || '';
    url = url.toLowerCase();
    id += encodeURIComponent(url) + '/';
    id += (request.method || '').toLowerCase();
    if (!isHistory && request.legacyProject) {
      id += '/' + request.legacyProject;
    }
    return id;
  }
  /**
   * Setss hours, minutes, seconds and ms to 0 and returns timestamp.
   *
   * @return {Number} Timestamp to the day.
   */
  _getDayToday(timestamp) {
    const d = new Date(timestamp);
    const tCheck = d.getTime();
    if (tCheck !== tCheck) {
      throw new Error('Invalid timestamp: ' + timestamp);
    }
    d.setMilliseconds(0);
    d.setSeconds(0);
    d.setMinutes(0);
    d.setHours(0);
    return d.getTime();
  }
  /**
   * Handler for request read event request.
   */
  _handleRead(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.id) {
      e.detail.result = Promise.reject(new Error('Request "id" property is missing.'));
      return;
    }
    if (!e.detail.type) {
      e.detail.result = Promise.reject(new Error('Request "type" property is missing.'));
      return;
    }
    e.detail.result = this.read(e.detail.type, e.detail.id, e.detail.rev)
    .catch((e) => this._handleException(e));
  }

  // Updates name of a request.
  _handleNameChange(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.name) {
      e.detail.result = Promise.reject(new Error('The "name" property is missing'));
      return;
    }
    if (!e.detail.type) {
      e.detail.result = Promise.reject(new Error('Request "type" property is missing.'));
      return;
    }
    const missingDataMsg = 'Either "request" object or request "id" must be set.';
    if (!e.detail.request && !e.detail.id) {
      e.detail.result = Promise.reject(new Error(missingDataMsg));
      return;
    }
    const request = e.detail.request;
    let promise;
    if (request && request._id && request._rev) {
      promise = Promise.resolve(request);
    } else {
      if (!e.detail.id) {
        e.detail.result = Promise.reject(new Error(missingDataMsg));
        return;
      }
      promise = this.read(e.detail.type, e.detail.id);
    }

    e.detail.result = promise
    .then((obj) => {
      obj = Object.assign({}, obj);
      obj.name = e.detail.name;
      return this.update(e.detail.type, obj);
    })
    .catch((e) => this._handleException(e));
  }
  // Handles onject save / update
  _handleObjectSave(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    const request = e.detail.request;
    if (!request) {
      e.detail.result = Promise.reject(new Error('The "request" property is missing.'));
      return;
    }
    if (!e.detail.type) {
      e.detail.result = Promise.reject(new Error('The "type" property is missing.'));
      return;
    }
    const db = this.getDatabase(e.detail.type);
    let p;
    if (request._id && !request._rev) {
      p = db.get(request._id)
      .catch((e) => {
        if (e.status === 404) {
          // create new
          return {};
        }
        this._handleException(e);
      });
    } else {
      p = Promise.resolve({});
    }
    e.detail.result = p
    .then((result) => {
      result = Object.assign({}, result, request);
      return this.update(e.detail.type, result);
    })
    .catch((e) => this._handleException(e));
  }
  // Deletes the object from the datastore.
  _handleObjectDelete(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.type) {
      e.detail.result = Promise.reject(new Error('Request "type" property is missing.'));
      return;
    }

    if (!e.detail.id) {
      e.detail.result = Promise.reject(new Error('Missing "id" property.'));
      return;
    }

    e.detail.result = this.remove(e.detail.type, e.detail.id, e.detail.rev)
    .catch((e) => this._handleException(e));
  }
  // Queries for a list of projects.
  _handleObjectsDelete(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.type) {
      e.detail.result = Promise.reject(new Error('Request "type" property is missing.'));
      return;
    }

    if (!e.detail.items) {
      e.detail.result = Promise.reject(new Error('The "items" property is missing.'));
      return;
    }
    const db = this.getDatabase(e.detail.type);
    let removed = [];
    e.detail.result = db.allDocs({
      keys: e.detail.items
    })
    .then((res) => this._filterExistingItems(res))
    .then((res) => {
      removed = res;
      return Promise.all(res.map((i) => db.remove(i.id, i.value.rev)));
    })
    .then((result) => {
      const data = {};
      result.forEach((item) => {
        if (item.ok) {
          const detail = {
            id: item.id,
            rev: item.rev,
            oldRev: this._findOldRef(removed, item.id)
          };
          data[item.id] = item.rev;
          this._fireUpdated('request-object-deleted', detail);
        }
      });
      return data;
    });
  }
  // handlers `request-objects-undeleted` event to restore deleted items
  _handleObjectsUndelete(e) {
    if (!e.cancelable || e.composedPath()[0] === this) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();

    if (!e.detail.type) {
      e.detail.result = Promise.reject(new Error('Request "type" property is missing.'));
      return;
    }

    if (!e.detail.items) {
      e.detail.result = Promise.reject(new Error('The "items" property is missing.'));
      return;
    }
    e.detail.result = this.revertRemove(e.detail.type, e.detail.items)
    .catch((e) => this._handleException(e));
  }
  /**
   * Filters query results to return only successfuly read data.
   * @param {Object} result PouchDB query result
   * @return {Array} List of request that has been read.
   */
  _filterExistingItems(result) {
    result = result.rows.filter((item) => {
      if (item.error) {
        console.error(item);
        return false;
      }
      return true;
    });
    return result;
  }

  _findOldRef(docs, id) {
    const result = docs.find((item) => item._id === id);
    return result ? result._rev : undefined;
  }

  /**
   * Fired when the project entity has been saved / updated in the datastore.
   *
   * @event request-object-changed
   * @param {Object} request Request object with new `_rev`.
   * @param {String} oldRev Entity old `_rev` property. May be `undefined` when
   * creating new entity.
   * @param {String} oldId Entity old `_id` property. May be `undefined` when
   * creating new entity.
   * @param {String} type Request object type. Can be either `saved-requests` or
   * `history-requests`
   */

  /**
   * @event request-object-deleted
   * @param {String} id Removed request ID
   * @param {String} rev Updated `_rev` property of the object.
   * @param {String} oldRev Entity old `_rev` property (before delete).
   * @param {String} type Request object type. Can be either `saved-requests` or
   * `history-requests`
   */
}
window.customElements.define(RequestModel.is, RequestModel);
</script>
