<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../chance/chance.js"></script>
  <script src="../demo/database-helper.js"></script>
  <link rel="import" href="../../app-pouchdb/pouchdb.html">
  <link rel="import" href="../arc-models.html">
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <request-model no-indexing></request-model>
    </template>
  </test-fixture>
  <script>
  /* global DatabaseHelper, PouchDB */
  function hasFormDataSupport() {
    const fd = new FormData();
    if (!('entries' in fd)) {
      return false;
    }
    return true;
  }

  suite('Save request with form data', function() {
    let element;
    let createdId;
    let createdRev;
    const defaultRequest = {
      url: 'test-url',
      method: 'test-method',
      headers: 'test-headers',
      payload: '',
      name: 'test'
    };

    suite('_blobToString()', function() {
      const b = new Blob(['***'], {type: 'text/plain'});
      setup(function() {
        element = fixture('Basic');
      });

      test('Returns a promise', function() {
        const result = element._blobToString(b);
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Promise results to a string', function() {
        return element._blobToString(b)
        .then((result) => assert.typeOf(result, 'string'));
      });

      test('String is a valid data url', function() {
        return element._blobToString(b)
        .then((result) => assert.equal(result, 'data:text/plain;base64,Kioq'));
      });
    });

    suite('_createMultipartEntry()', function() {
      let fd;
      setup(function() {
        const b = new Blob(['***'], {type: 'text/plain'});
        fd = new FormData();
        fd.append('file', b, 'file-name');
        fd.append('text', 'abcd');
        fd.append('text-part', b, 'text-part');
        fd._arcMeta = {
          textParts: ['text-part']
        };
        element = fixture('Basic');
      });

      test('Returns a promise', function() {
        const result = element._createMultipartEntry(fd);
        assert.typeOf(result.then, 'function');
        return result;
      });

      test('Promise results to an array', function() {
        return element._createMultipartEntry(fd)
        .then((result) => assert.typeOf(result, 'array'));
      });

      test('Computes file part', () => {
        return element._createMultipartEntry(fd)
        .then((data) => {
          const part = data[0];
          assert.isTrue(part.isFile);
          assert.equal(part.name, 'file');
          assert.equal(part.value, 'data:text/plain;base64,Kioq');
        });
      });

      test('Computes text part', () => {
        return element._createMultipartEntry(fd)
        .then((data) => {
          const part = data[1];
          assert.isFalse(part.isFile);
          assert.equal(part.name, 'text');
          assert.equal(part.value, 'abcd');
        });
      });

      test('Sets isTextBlob', () => {
        return element._createMultipartEntry(fd)
        .then((data) => {
          const part = data[2];
          assert.isFalse(part.isFile);
          assert.isTrue(part.isTextBlob);
          assert.equal(part.name, 'text-part');
          assert.equal(part.value, 'data:text/plain;base64,Kioq');
        });
      });
    });

    function db() {
      return new PouchDB('saved-requests');
    }

    function setCreatedData(result) {
      createdId = result._id;
      createdRev = result._rev;
    }
    suite('Simple save', function() {
      setup(function() {
        createdId = undefined;
        createdRev = undefined;
        element = fixture('Basic');
        defaultRequest.payload = new FormData();
        defaultRequest.payload.append('test', 'value');
        defaultRequest.payload.append('file', new Blob(['a'], {
          type: 'application/x-test'
        }), 'test.txt');
      });

      teardown(function() {
        if (createdId) {
          return db().remove(createdId, createdRev);
        }
      });

      suiteTeardown(function() {
        return db().destroy();
      });

      test('Creates request object', function() {
        return element.saveRequest(Object.assign({}, defaultRequest))
        .then((result) => {
          setCreatedData(result);
        });
      });

      test('Created entry\'s payload is cleared', function() {
        return element.saveRequest(Object.assign({}, defaultRequest))
        .then((result) => {
          setCreatedData(result);
          assert.isUndefined(result.payload);
        });
      });

      test('Created entry contains multipart property', function() {
        if (!hasFormDataSupport()) {
          return;
        }
        return element.saveRequest(Object.assign({}, defaultRequest))
        .then((result) => {
          setCreatedData(result);
          assert.typeOf(result.multipart, 'array');
        });
      });

      test('Contains text entry', function() {
        if (!hasFormDataSupport()) {
          return;
        }
        return element.saveRequest(Object.assign({}, defaultRequest))
        .then((result) => {
          setCreatedData(result);
          assert.isFalse(result.multipart[0].isFile);
          assert.equal(result.multipart[0].name, 'test');
          assert.typeOf(result.multipart[0].value, 'string');
        });
      });

      test('Contains file entry', function() {
        if (!hasFormDataSupport()) {
          return;
        }
        return element.saveRequest(Object.assign({}, defaultRequest))
        .then((result) => {
          setCreatedData(result);
          assert.isTrue(result.multipart[1].isFile);
          assert.equal(result.multipart[1].name, 'file');
          assert.typeOf(result.multipart[1].value, 'string');
        });
      });
    });

    suite('Save request with File data', function() {
      let element;
      let createdId;
      let createdRev;
      const defaultRequest = {
        url: 'test-url',
        method: 'test-method',
        headers: 'test-headers',
        payload: '',
        name: 'test'
      };

      function db() {
        return new PouchDB('saved-requests');
      }

      function setCreatedData(result) {
        createdId = result._id;
        createdRev = result._rev;
      }
      suite('Simple save', function() {
        setup(function() {
          element = fixture('Basic');
          const b = new Blob(['a'], {
            type: 'application/x-test'
          });
          b.name = 'test.txt'; // mimics file object
          defaultRequest.payload = b;
        });
        teardown(function() {
          if (createdId) {
            return db().remove(createdId, createdRev);
          }
        });
        suiteTeardown(function() {
          return db().destroy();
        });
        test('Creates request object', function() {
          return element.saveRequest(Object.assign({}, defaultRequest))
            .then((result) => {
              setCreatedData(result);
            });
        });
        test('Created entry\'s payload is cleared', function() {
          return element.saveRequest(Object.assign({}, defaultRequest))
            .then((result) => {
              setCreatedData(result);
              assert.isUndefined(result.payload);
            });
        });
        test('Created entry contains blob property', function() {
          return element.saveRequest(Object.assign({}, defaultRequest))
            .then((result) => {
              setCreatedData(result);
              assert.typeOf(result.blob, 'string');
            });
        });

        function dataURLtoBlob(dataurl) {
          const arr = dataurl.split(',');
          const mime = arr[0].match(/:(.*?);/)[1];
          const bstr = atob(arr[1]);
          let n = bstr.length;
          const u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          return new Blob([u8arr], {
            type: mime
          });
        }
        test('Blob entry can be restored', function() {
          return element.saveRequest(Object.assign({}, defaultRequest))
            .then((result) => {
              setCreatedData(result);
              const blob = dataURLtoBlob(result.blob);
              assert.equal(blob.size, defaultRequest.payload.size);
            });
        });
      });
    });
  });

  let clearHistory = false;
  let clearSaved = false;
  let clearProjects = false;
  function databaseCleanup() {
    const p = [];
    if (clearHistory) {
      p.push(DatabaseHelper.clearHistory());
    }
    if (clearSaved) {
      p.push(DatabaseHelper.clearRequests());
    }
    if (clearProjects) {
      p.push(DatabaseHelper.clearProjects());
    }
    return Promise.all(p);
  }
  suite('saveRequest()', function() {
    suite('Request type setup', function() {
      let element;

      setup(() => {
        clearHistory = false;
        clearSaved = false;
        clearProjects = false;
        element = fixture('Basic');
      });

      teardown(() => databaseCleanup());

      test('Sets history if no name', function() {
        clearHistory = true;
        const request = DatabaseHelper.generateHistoryObject();
        delete request.type;
        return element.saveRequest(request)
        .then((request) => {
          assert.equal(request.type, 'history');
        });
      });

      test('Sets saved if name', function() {
        clearSaved = true;
        const request = DatabaseHelper.generateSavedItem();
        delete request.type;
        return element.saveRequest(request)
        .then((request) => {
          assert.equal(request.type, 'saved');
        });
      });

      test('Keeps type if defined', function() {
        clearSaved = true;
        const request = DatabaseHelper.generateHistoryObject();
        request.type = 'saved';
        return element.saveRequest(request)
        .then((request) => {
          assert.equal(request.type, 'saved');
        });
      });

      test('Renames "drive" to "saved"', function() {
        clearSaved = true;
        const request = DatabaseHelper.generateHistoryObject();
        request.type = 'drive';
        return element.saveRequest(request)
        .then((request) => {
          assert.equal(request.type, 'saved');
        });
      });

      test('Renames "google-drive" to "saved"', function() {
        clearSaved = true;
        const request = DatabaseHelper.generateHistoryObject();
        request.type = 'google-drive';
        return element.saveRequest(request)
        .then((request) => {
          assert.equal(request.type, 'saved');
        });
      });
    });

    suite('Request id and rev', function() {
      let element;
      setup(() => {
        clearHistory = false;
        clearSaved = false;
        clearProjects = false;
        element = fixture('Basic');
      });

      teardown(() => databaseCleanup());

      test('Generates an ID for the request', () => {
        clearHistory = true;
        const request = DatabaseHelper.generateHistoryObject();
        delete request._id;
        return element.saveRequest(request)
        .then((request) => {
          assert.typeOf(request._id, 'string');
        });
      });

      test('Returns the REV proeprty', () => {
        clearHistory = true;
        const request = DatabaseHelper.generateHistoryObject();
        return element.saveRequest(request)
        .then((request) => {
          assert.typeOf(request._rev, 'string');
        });
      });
    });

    suite('Google Drive save', function() {
      let element;
      let handleDriveEvent;

      function driveHandler(e) {
        if (!handleDriveEvent) {
          return;
        }
        e.preventDefault();
        e.detail.result = Promise.resolve({
          id: 'test-drive-id'
        });
      }

      suiteSetup(() => {
        window.addEventListener('export-google-drive', driveHandler);
      });

      suiteTeardown(() => {
        window.removeEventListener('export-google-drive', driveHandler);
      });

      setup(() => {
        handleDriveEvent = false;
        clearHistory = false;
        clearSaved = false;
        clearProjects = false;
        element = fixture('Basic');
      });

      teardown(() => databaseCleanup());

      test('Event is not dispatched when no drive info', () => {
        clearSaved = true;
        const request = DatabaseHelper.generateSavedItem();
        const spy = sinon.spy();
        element.addEventListener('export-google-drive', spy);
        return element.saveRequest(request)
        .then(() => {
          assert.isFalse(spy.called);
        });
      });

      test('Rejects the promise when event not handled', (done) => {
        const request = DatabaseHelper.generateSavedItem();
        element.saveRequest(request, {isDrive: true})
        .then(() => {
          clearSaved = true;
          done(new Error('Save request finished with success'));
        })
        .catch(() => {
          done();
        });
      });

      test('Updates driveId on the model', function() {
        handleDriveEvent = true;
        clearSaved = true;
        const request = DatabaseHelper.generateSavedItem();
        return element.saveRequest(request, {isDrive: true})
        .then((request) => {
          assert.equal(request.driveId, 'test-drive-id');
        });
      });

      test('Event contains request copy', () => {
        clearSaved = true;
        handleDriveEvent = true;
        const request = DatabaseHelper.generateSavedItem();
        let eventData;
        element.addEventListener('export-google-drive', function f(e) {
          element.removeEventListener('export-google-drive', f);
          eventData = e.detail;
          eventData.content.url = 'test-url';
        });
        return element.saveRequest(request, {isDrive: true})
        .then(() => {
          assert.typeOf(eventData, 'object');
          assert.notEqual(request.url, 'test-url');
        });
      });

      test('Event contains contentType', () => {
        clearSaved = true;
        handleDriveEvent = true;
        const request = DatabaseHelper.generateSavedItem();
        let eventData;
        element.addEventListener('export-google-drive', function f(e) {
          element.removeEventListener('export-google-drive', f);
          eventData = e.detail;
        });
        return element.saveRequest(request, {isDrive: true})
        .then(() => {
          assert.equal(eventData.contentType, 'application/json');
        });
      });

      test('Event contains file', () => {
        clearSaved = true;
        handleDriveEvent = true;
        const request = DatabaseHelper.generateSavedItem();
        request.name = 'test';
        let eventData;
        element.addEventListener('export-google-drive', function f(e) {
          element.removeEventListener('export-google-drive', f);
          eventData = e.detail;
        });
        return element.saveRequest(request, {isDrive: true})
        .then(() => {
          assert.equal(eventData.file, 'test.arc');
        });
      });
    });

    suite('_createProjects()', function() {
      let element;
      const names = ['a', 'b', 'c'];
      const requestId = 'test-id';
      setup(() => {
        clearHistory = false;
        clearSaved = false;
        clearProjects = true;
        element = fixture('Basic');
      });

      teardown(() => databaseCleanup());

      test('Creates a list of projects from names', function() {
        return element._createProjects(names)
        .then(() => DatabaseHelper.allProjects())
        .then((list) => {
          assert.lengthOf(list, 3, 'Has 3 items');
          for (let i = 0; i < list.length; i++) {
            assert.notEqual(names.indexOf(list[i].name), -1);
          }
        });
      });

      test('Adds a request id to the project', function() {
        return element._createProjects(names, requestId)
        .then(() => DatabaseHelper.allProjects())
        .then((list) => {
          assert.lengthOf(list, 3, 'Has 3 items');
          for (let i = 0; i < list.length; i++) {
            assert.equal(list[i].requests[0], 'test-id');
          }
        });
      });
    });

    suite('Synchronizes projects', function() {
      let element;
      let projects;
      let createProjectRequestId;
      setup(() => {
        clearHistory = false;
        clearSaved = true;
        clearProjects = true;
        element = fixture('Basic');
        return element._createProjects(['a', 'b', 'c'], createProjectRequestId)
        .then((data) => {
          projects = data;
        });
      });

      teardown(() => databaseCleanup());

      test('Sets request ID on projects', function() {
        const request = DatabaseHelper.generateSavedItem();
        request._id = 'test-projects';
        request.projects = projects;
        return element.saveRequest(request)
        .then(() => DatabaseHelper.allProjects())
        .then((list) => {
          for (let i = 0; i < list.length; i++) {
            assert.equal(list[i].requests[0], 'test-projects');
          }
        });
      });

      test('Sets request ID on single project', function() {
        const request = DatabaseHelper.generateSavedItem();
        request._id = 'test-projects';
        request.projects = [projects[1]];
        return element.saveRequest(request)
        .then(() => DatabaseHelper.allProjects())
        .then((list) => {
          for (let i = 0; i < list.length; i++) {
            if (list[i]._id === projects[1]) {
              assert.equal(list[i].requests[0], 'test-projects');
            } else {
              assert.lengthOf(list[i].requests, 0);
            }
          }
        });
      });

      test('Just setting a flag for the next test', () => {
        createProjectRequestId = 'test-projects';
      });

      test('Removes request ID prom projects', function() {
        createProjectRequestId = undefined;
        const request = DatabaseHelper.generateSavedItem();
        request._id = 'test-projects';
        request.projects = [projects[1]];
        return element.saveRequest(request)
        .then(() => DatabaseHelper.allProjects())
        .then((list) => {
          for (let i = 0; i < list.length; i++) {
            if (list[i]._id === projects[1]) {
              assert.equal(list[i].requests[0], 'test-projects');
            } else {
              assert.lengthOf(list[i].requests, 0);
            }
          }
        });
      });
    });
  });
  </script>
</body>

</html>
