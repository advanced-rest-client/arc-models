<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../web-component-tester/browser.js"></script>
    <script src="../../../iron-test-helpers/test-helpers.js"></script>
    <link rel="import" href="../../../app-pouchdb/pouchdb.html">
    <link rel="import" href="../../url-indexer.html">
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <url-indexer></url-indexer>
      </template>
    </test-fixture>

    <script>
    suite('URL indexer', function() {
      function noop() {}
      const hasUrlSupport = typeof URL !== 'undefined';
      suite('UUID generation', () => {
        let element;
        setup(function(done) {
          element = fixture('Basic');
          flush(() => done());
        });

        test('Returns a reference to uuid-generator', () => {
          const result = element.uuid;
          assert.equal(result.nodeName, 'UUID-GENERATOR');
        });

        test('Returns the same element', () => {
          const result1 = element.uuid;
          const result2 = element.uuid;
          assert.isTrue(result1 === result2);
        });

        test('Generates UUID', () => {
          const result = element.uuid.generate();
          assert.typeOf(result, 'string');
        });
      });

      suite('_generateId()', () => {
        let element;
        const type = 'test-type';
        const url = 'test-url';
        setup(function(done) {
          element = fixture('Basic');
          flush(() => done());
        });

        test('Returns a string', () => {
          const result = element._generateId(url, type);
          assert.typeOf(result, 'string');
        });

        test('Contains URL', () => {
          const result = element._generateId(url, type);
          assert.equal(result.indexOf(url), 0);
        });

        test('Contains type', () => {
          const result = element._generateId(url, type);
          assert.isAbove(result.indexOf(type), 1);
        });

        test('Contains uuid', () => {
          const result = element._generateId(url, type);
          const parts = result.split('::');
          assert.typeOf(parts[2], 'string');
        });
      });

      suite('Getters', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
        });

        test('indexStoreName is string', () => {
          assert.typeOf(element.indexStoreName, 'string');
        });

        test('indexStoreName is store name', () => {
          assert.equal(element.indexStoreName, 'request-index');
        });

        test('indexStoreVersion is a number', () => {
          assert.typeOf(element.indexStoreVersion, 'number');
        });

        test('indexStoreVersion is version number', () => {
          assert.equal(element.indexStoreVersion, 1);
        });
      });

      suite('_indexDebounce()', () => {
        let element;
        const id = 'test-id';
        const url = 'test-url';
        const type = 'test-type';
        setup(function() {
          element = fixture('Basic');
          element.index = noop;
        });

        test('Sets __indexDebounce property', () => {
          element._indexDebounce(id, url, type);
          assert.typeOf(element.__indexDebounce, 'number');
          clearTimeout(element.__indexDebounce);
          element.__indexRequestQueue = undefined;
        });

        test('Sets __indexRequestQueue property', () => {
          element._indexDebounce(id, url, type);
          assert.typeOf(element.__indexRequestQueue, 'array', 'Array is set');
          assert.lengthOf(element.__indexRequestQueue, 1, 'Has single item');
          clearTimeout(element.__indexDebounce);
          element.__indexRequestQueue = undefined;
        });

        test('__indexRequestQueue item has all properties', () => {
          element._indexDebounce(id, url, type);
          const item = element.__indexRequestQueue[0];
          assert.equal(item.id, id);
          assert.equal(item.url, url);
          assert.equal(item.type, type);
          clearTimeout(element.__indexDebounce);
          element.__indexRequestQueue = undefined;
        });

        test('Updates URL if the same request is called before flush', (done) => {
          element._indexDebounce(id, url, type);
          setTimeout(() => {
            element._indexDebounce(id, 'url-2', 'type-2');
            const item = element.__indexRequestQueue[0];
            assert.equal(item.url, 'url-2');
            clearTimeout(element.__indexDebounce);
            element.__indexRequestQueue = undefined;
            done();
          }, 1);
        });

        test('Updates type if the same request is called before flush', (done) => {
          element._indexDebounce(id, url, type);
          setTimeout(() => {
            element._indexDebounce(id, 'url-2', 'type-2');
            const item = element.__indexRequestQueue[0];
            assert.equal(item.type, 'type-2');
            clearTimeout(element.__indexDebounce);
            element.__indexRequestQueue = undefined;
            done();
          }, 1);
        });

        test('Flushes the queue', (done) => {
          element._indexDebounce(id, url, type);
          element.index = () => {
            done();
            return Promise.resolve();
          };
        });

        test('Calls index with params', (done) => {
          element._indexDebounce(id, url, type);
          element.index = (data) => {
            assert.typeOf(data, 'array');
            assert.lengthOf(data, 1, 'Has single item');
            done();
            return Promise.resolve();
          };
        });

        test('Calls index with params', (done) => {
          element._indexDebounce(id, url, type);
          element.index = (data) => {
            assert.typeOf(data, 'array');
            assert.lengthOf(data, 1, 'Has single item');
            const item = data[0];
            assert.equal(item.id, id);
            assert.equal(item.url, url);
            assert.equal(item.type, type);
            done();
            return Promise.resolve();
          };
        });

        test('Clears __indexDebounce', (done) => {
          element._indexDebounce(id, url, type);
          element.index = () => {
            assert.isUndefined(element.__indexDebounce);
            done();
            return Promise.resolve();
          };
        });

        test('Clears __indexRequestQueue', (done) => {
          element._indexDebounce(id, url, type);
          element.index = () => {
            assert.isUndefined(element.__indexRequestQueue);
            done();
            return Promise.resolve();
          };
        });
      });

      suite('_deleteIndexDebounce()', () => {
        let element;
        const id = 'test-id';
        setup(function() {
          element = fixture('Basic');
          element.deleteIndexedData = noop;
        });

        test('Sets __deleteIndexDebounce property', () => {
          element._deleteIndexDebounce(id);
          assert.typeOf(element.__deleteIndexDebounce, 'number');
          clearTimeout(element.__deleteIndexDebounce);
          element.__deleteRequestQueue = undefined;
        });

        test('Sets __deleteRequestQueue property', () => {
          element._deleteIndexDebounce(id);
          assert.typeOf(element.__deleteRequestQueue, 'array', 'Array is set');
          assert.lengthOf(element.__deleteRequestQueue, 1, 'Has single item');
          clearTimeout(element.__deleteIndexDebounce);
          element.__deleteRequestQueue = undefined;
        });

        test('__deleteRequestQueue item has the id', () => {
          element._deleteIndexDebounce(id);
          const result = element.__deleteRequestQueue[0];
          assert.equal(result, id);
          clearTimeout(element.__deleteIndexDebounce);
          element.__deleteRequestQueue = undefined;
        });

        test('Does nothing if repeates the call', (done) => {
          element._deleteIndexDebounce(id);
          setTimeout(() => {
            element._deleteIndexDebounce(id);
            assert.typeOf(element.__deleteRequestQueue, 'array', 'Array is set');
            assert.lengthOf(element.__deleteRequestQueue, 1, 'Has single item');
            const result = element.__deleteRequestQueue[0];
            assert.equal(result, id);
            clearTimeout(element.__deleteIndexDebounce);
            element.__deleteRequestQueue = undefined;
            done();
          }, 1);
        });

        test('Flushes the queue', (done) => {
          element._deleteIndexDebounce(id);
          element.deleteIndexedData = () => {
            done();
            return Promise.resolve();
          };
        });

        test('Calls deleteIndexedData with params', (done) => {
          element._deleteIndexDebounce(id);
          element.deleteIndexedData = (data) => {
            assert.typeOf(data, 'array');
            assert.lengthOf(data, 1, 'Has single item');
            done();
            return Promise.resolve();
          };
        });

        test('Calls index with params', (done) => {
          element._deleteIndexDebounce(id);
          element.deleteIndexedData = (data) => {
            assert.typeOf(data, 'array');
            assert.lengthOf(data, 1, 'Has single item');
            const result = data[0];
            assert.equal(result, id);
            done();
            return Promise.resolve();
          };
        });

        test('Clears __indexDebounce', (done) => {
          element._deleteIndexDebounce(id);
          element.deleteIndexedData = () => {
            assert.isUndefined(element.__deleteIndexDebounce);
            done();
            return Promise.resolve();
          };
        });

        test('Clears __deleteRequestQueue', (done) => {
          element._deleteIndexDebounce(id);
          element.deleteIndexedData = () => {
            assert.isUndefined(element.__deleteRequestQueue);
            done();
            return Promise.resolve();
          };
        });
      });

      suite('_prepareRequestIndexData()', function() {
        let element;
        let request;
        setup(function() {
          element = fixture('Basic');
          request = {
            id: 'test-id',
            url: 'https://domain.com/Api/Path?p1=1&p2=2',
            type: 'saved'
          };
        });

        test('Always returns an array', function() {
          const result = element._prepareRequestIndexData(request, []);
          assert.typeOf(result, 'array');
        });

        test('Returns 8 items', function() {
          if (!hasUrlSupport) {
            return;
          }
          const result = element._prepareRequestIndexData(request, []);
          assert.lengthOf(result, 8);
        });

        test('Skips already indexed items', function() {
          if (!hasUrlSupport) {
            return;
          }
          const result = element._prepareRequestIndexData(request, [{
            url: 'p1=1&p2=2'
          }, {
            url: '/api/path?p1=1&p2=2'
          }, {
            url: '/notexist'
          }]);
          assert.lengthOf(result, 6);
        });

        test('Items has required structure', function() {
          if (!hasUrlSupport) {
            return;
          }
          const result = element._prepareRequestIndexData(request, []);
          for (let i = 0; i < result.length; i++) {
            const item = result[i];
            assert.equal(item.type, 'saved');
            assert.typeOf(item.url, 'string');
            assert.equal(item.id.indexOf(item.url.toLowerCase() + '::' + item.type), 0);
          }
        });
      });

      suite('_createIndexIfMissing()', () => {
        let element;
        const id = 'test-id';
        const url = 'test-url';
        const type = 'test-type';
        let indexed;
        setup(function() {
          element = fixture('Basic');
          indexed = [];
        });

        test('Creates datastore entry if not exists', () => {
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.typeOf(result, 'object');
        });

        test('Datastore entry has id', () => {
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.typeOf(result.id, 'string');
        });

        test('Datastore entry has url', () => {
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.equal(result.url, url);
        });

        test('Datastore entry has requestId', () => {
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.equal(result.requestId, id);
        });

        test('Datastore entry has type', () => {
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.equal(result.type, type);
        });

        test('Datastore entry has fullUrl', () => {
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.strictEqual(result.fullUrl, 0);
        });

        test('Returns undefined if the item is already indexed', () => {
          indexed = [{
            url
          }];
          const result = element._createIndexIfMissing(url, id, type, indexed);
          assert.isUndefined(result);
        });
      });

      suite('_getUrlObject()', () => {
        let element;
        const id = 'test-id';
        const url = 'test-url';
        const type = 'test-type';
        let indexed;
        let request;
        setup(function() {
          element = fixture('Basic');
          indexed = [];
          request = {
            id,
            url,
            type
          };
        });

        test('Creates index entity when not indexed', () => {
          const result = element._getUrlObject(request, indexed);
          assert.typeOf(result, 'object');
        });

        test('Returns undefined if already indexed', () => {
          indexed = [{
            url
          }];
          const result = element._getUrlObject(request, indexed);
          assert.isUndefined(result);
        });
      });

      suite('_getAuthorityPath()', () => {
        let element;
        const id = 'test-id';
        const url = 'https://domain.com';
        const type = 'test-type';
        let indexed;
        let parser;
        setup(function() {
          element = fixture('Basic');
          indexed = [];
          parser = new URL(url);
        });

        test('Creates index entity when not indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          const result = element._getAuthorityPath(parser, id, type, indexed);
          assert.typeOf(result, 'object');
        });

        test('Returns undefined if already indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          const url = element._getAuthorityPath(parser, id, type, indexed).url;
          indexed = [{
            url
          }];
          const result = element._getAuthorityPath(parser, id, type, indexed);
          assert.isUndefined(result);
        });
      });

      suite('_getPathQuery()', () => {
        let element;
        const id = 'test-id';
        const url = 'https://domain.com?a=b';
        const type = 'test-type';
        let indexed;
        let parser;
        setup(function() {
          element = fixture('Basic');
          indexed = [];
          parser = new URL(url);
        });

        test('Creates index entity when not indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          const result = element._getPathQuery(parser, id, type, indexed);
          assert.typeOf(result, 'object');
        });

        test('Returns undefined if already indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          const url = element._getPathQuery(parser, id, type, indexed).url;
          indexed = [{
            url
          }];
          const result = element._getPathQuery(parser, id, type, indexed);
          assert.isUndefined(result);
        });
      });

      suite('_getQueryString()', () => {
        let element;
        const id = 'test-id';
        const url = 'https://domain.com?a=b';
        const type = 'test-type';
        let indexed;
        let parser;
        setup(function() {
          element = fixture('Basic');
          indexed = [];
          parser = new URL(url);
        });

        test('Creates index entity when not indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          const result = element._getQueryString(parser, id, type, indexed);
          assert.typeOf(result, 'object');
        });

        test('Returns undefined if already indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          const url = element._getQueryString(parser, id, type, indexed).url;
          indexed = [{
            url
          }];
          const result = element._getQueryString(parser, id, type, indexed);
          assert.isUndefined(result);
        });
      });

      suite('_appendQueryParams()', () => {
        let element;
        const id = 'test-id';
        const url = 'https://domain.com?a=b';
        const type = 'test-type';
        let indexed;
        let parser;
        let target;
        setup(function() {
          element = fixture('Basic');
          indexed = [];
          target = [];
          parser = new URL(url);
        });

        test('Adds index entity when not indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          element._appendQueryParams(parser, id, type, indexed, target);
          assert.lengthOf(target, 2);
        });

        test('Returns undefined if already indexed', () => {
          if (!hasUrlSupport) {
            return;
          }
          element._appendQueryParams(parser, id, type, indexed, target);
          indexed = [{
            url: target[0].url
          }, {
            url: target[1].url
          }];
          target = [];
          element._appendQueryParams(parser, id, type, indexed, target);
          assert.lengthOf(target, 0);
        });
      });

      suite('openSearchStore()', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
        });

        // suiteTeardown(() => DbHelper.clearData());

        // suiteTeardown((done) => {
        //   DbHelper.clearData()
        //   .then(() => {
        //     element.__db.close();
        //     const request = window.indexedDB.deleteDatabase('request-index');
        //     request.onerror = function() {
        //       done(new Error('Unable to delete database'));
        //     };
        //     request.onsuccess = function() {
        //       done();
        //     };
        //   });
        // });

        test('Eventually opens the data store', () => {
          return element.openSearchStore()
          .then((db) => {
            assert.isTrue(db instanceof window.IDBDatabase);
          });
        });

        test('Always returns the same database instance', () => {
          let db1;
          return element.openSearchStore()
          .then((db) => {
            db1 = db;
            return element.openSearchStore();
          })
          .then((db2) => {
            assert.isTrue(db1 === db2);
          });
        });
      });
    });
    </script>

  </body>
</html>
