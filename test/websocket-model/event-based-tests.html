<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../../mocha/mocha.js"></script>
    <script src="../../../../chai/chai.js"></script>
    <script src="../../../../wct-mocha/wct-mocha.js"></script>

  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <websocket-url-history-model></websocket-url-history-model>
      </template>
    </test-fixture>

    <script type="module">
      import {DataGenerator} from '../../../../@advanced-rest-client/arc-data-generator/arc-data-generator.js';
      import '../../../../pouchdb/dist/pouchdb.js';
      import '../../websocket-url-history-model.js';
      import sinon from '../../../../sinon/pkg/sinon-esm.js';

      suite('Events API for websocket url history', function() {
        // See https://gist.github.com/haroldtreen/5f1055eee5fcf01da3e0e15b8ec86bf6
        function isError(e) {
          if (typeof e === 'string') {
            return Promise.reject(new Error(e));
          }
          return Promise.resolve(e);
        }

        function fireChanged(item) {
          const e = new CustomEvent('websocket-url-history-changed', {
            detail: {
              item: item
            },
            bubbles: true,
            composed: true,
            cancelable: true
          });
          document.body.dispatchEvent(e);
          return e;
        }

        suite('websocket-url-history-changed', function() {
          teardown(function() {
            return DataGenerator.destroyWebsocketsData();
          });

          let element;
          let dataObj;
          setup(function() {
            element = fixture('basic');
            dataObj = {
              _id: 'http://domain.com',
              cnt: 1,
              time: Date.now()
            };
          });

          test('Ignores non-cancellable event', () => {
            const e = {
              cancelable: false,
              detail: {
                item: dataObj
              }
            };
            element._handleChange(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores cancelled event', () => {
            const e = {
              cancelable: true,
              defaultPrevented: true,
              detail: {
                item: dataObj
              }
            };
            element._handleChange(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores self dispatched events', () => {
            const e = {
              cancelable: true,
              composedPath: function() {
                return [element];
              },
              detail: {
                item: dataObj
              }
            };
            element._handleChange(e);
            assert.isUndefined(e.detail.result);
          });

          test('Event is canceled', function() {
            const e = fireChanged(dataObj);
            assert.isTrue(e.defaultPrevented);
            return e.detail.result;
          });

          test('Event detail contains "result" as promise', function() {
            const e = fireChanged(dataObj);
            assert.typeOf(e.detail.result, 'promise');
            return e.detail.result;
          });

          test('Creates a new object in the datastore', function() {
            const e = fireChanged(dataObj);
            return e.detail.result
            .then((result) => {
              assert.typeOf(result._rev, 'string', '_rev is set');
              assert.typeOf(result._id, 'string', '_id is set');
              assert.equal(result.cnt, dataObj.cnt, 'cnt is set');
              assert.equal(result.time, dataObj.time, 'time is set');
            });
          });

          test('Updates created object', function() {
            let originalRev;
            let originalId;
            const e = fireChanged(dataObj);
            return e.detail.result
            .then((result) => {
              originalRev = result._rev;
              originalId = result._id;
              result.cnt = 2;
              const e = fireChanged(result);
              return e.detail.result;
            })
            .then((result) => {
              assert.notEqual(result._rev, originalRev, '_rev is regenerated');
              assert.equal(result._id, originalId, '_id is the same');
              assert.equal(result.cnt, 2, 'Name is set');
            });
          });

          test('Rejects promise when save object is not set', function() {
            const e = fireChanged();
            return e.detail.result
            .then(() => {
              return Promise.reject('Expected method to reject.');
            })
            .catch(isError)
            .then((err) => {
              assert.isDefined(err);
            });
          });

          test('Rejects promise when save object has no id', function() {
            const cp = Object.assign({}, dataObj);
            cp._id = undefined;
            const e = fireChanged(cp);
            return e.detail.result
            .then(() => {
              return Promise.reject('Expected method to reject.');
            })
            .catch(isError)
            .then((err) => {
              assert.isDefined(err);
            });
          });

          test('Handles exceptions', () => {
            const e = {
              cancelable: true,
              composedPath: () => [],
              preventDefault: () => {},
              stopPropagation: () => {},
              detail: {
                item: dataObj
              }
            };
            element.update = () => {
              return Promise.reject(new Error('test'));
            };
            let called = false;
            element._handleChange(e);
            return e.detail.result
            .catch((cause) => {
              if (cause.message === 'test') {
                called = true;
              }
            })
            .then(() => {
              assert.isTrue(called);
            });
          });
        });

        suite('websocket-url-history-read', function() {
          teardown(function() {
            return DataGenerator.destroyWebsocketsData();
          });

          let element;
          let dataObj;
          setup(function() {
            element = fixture('basic');
            dataObj = {
              _id: 'http://domain.com',
              cnt: 1,
              time: Date.now()
            };
            const e = fireChanged(dataObj);
            return e.detail.result
            .then((result) => dataObj = result);
          });

          function fire(id) {
            const e = new CustomEvent('websocket-url-history-read', {
              detail: {
                url: id
              },
              bubbles: true,
              composed: true,
              cancelable: true
            });
            document.body.dispatchEvent(e);
            return e;
          }

          test('Ignores non-cancellable event', () => {
            const element = fixture('basic');
            const e = {
              cancelable: false,
              detail: {
                url: dataObj._id
              }
            };
            element._handleRead(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores cancelled event', () => {
            const element = fixture('basic');
            const e = {
              cancelable: true,
              defaultPrevented: true,
              detail: {
                url: dataObj._id
              }
            };
            element._handleRead(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores self dispatched events', () => {
            const element = fixture('basic');
            const e = {
              cancelable: true,
              composedPath: function() {
                return [element];
              },
              detail: {
                url: dataObj._id
              }
            };
            element._handleRead(e);
            assert.isUndefined(e.detail.result);
          });

          test('Event is canceled', function() {
            const e = fire(dataObj._id);
            assert.isTrue(e.defaultPrevented);
            return e.detail.result;
          });

          test('Event detail contains "result" as promise', function() {
            const e = fire(dataObj._id);
            assert.typeOf(e.detail.result, 'promise');
            return e.detail.result;
          });

          test('Reads an object', function() {
            const e = fire(dataObj._id);
            return e.detail.result
            .then((result) => {
              assert.equal(result._id, dataObj._id);
            });
          });

          test('Rejects promise when no ID', function() {
            const e = fire();
            return e.detail.result
            .then(() => {
              return Promise.reject('Expected method to reject.');
            })
            .catch(isError)
            .then((err) => {
              assert.isDefined(err);
            });
          });

          test('Returns undefined when no object', function() {
            const e = fire('test-id-non-existing');
            return e.detail.result
            .then((result) => {
              assert.isUndefined(result);
            });
          });

          test('Handles exceptions', () => {
            element.read = () => {
              return Promise.reject(new Error('test'));
            };
            const e = fire('test-id-non-existing');
            let called = false;
            return e.detail.result
            .catch((cause) => {
              if (cause.message === 'test') {
                called = true;
              }
            })
            .then(() => {
              assert.isTrue(called);
            });
          });
        });

        suite('websocket-url-history-query', function() {
          teardown(function() {
            return DataGenerator.destroyWebsocketsData();
          });

          let element;
          let dataObj;
          setup(function() {
            element = fixture('basic');
            dataObj = {
              _id: 'http://domain.com',
              cnt: 1,
              time: Date.now()
            };
            const e = fireChanged(dataObj);
            return e.detail.result
            .then((result) => dataObj = result);
          });

          function fire(q) {
            const e = new CustomEvent('websocket-url-history-query', {
              detail: {
                q
              },
              bubbles: true,
              composed: true,
              cancelable: true
            });
            document.body.dispatchEvent(e);
            return e;
          }

          test('Ignores non-cancellable event', () => {
            const e = {
              cancelable: false,
              detail: {
                q: 'test'
              }
            };
            element._handleQuery(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores cancelled event', () => {
            const e = {
              cancelable: true,
              defaultPrevented: true,
              detail: {
                q: 'test'
              }
            };
            element._handleQuery(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores self dispatched events', () => {
            const e = {
              cancelable: true,
              composedPath: function() {
                return [element];
              },
              detail: {
                q: 'test'
              }
            };
            element._handleQuery(e);
            assert.isUndefined(e.detail.result);
          });

          test('Event is canceled', function() {
            const e = fire('http');
            assert.isTrue(e.defaultPrevented);
            return e.detail.result;
          });

          test('Event detail contains "result" as promise', function() {
            const e = fire('http');
            assert.typeOf(e.detail.result, 'promise');
            return e.detail.result;
          });

          test('Returns a list of results', function() {
            const e = fire('http');
            return e.detail.result
            .then((result) => {
              assert.typeOf(result, 'array', 'Result is an array');
              assert.lengthOf(result, 1, 'Length is OK');
            });
          });

          test('Returned items contains _time property', function() {
            const e = fire('http');
            return e.detail.result
            .then((result) => {
              assert.typeOf(result[0]._time, 'number', '_time is a number');
            });
          });

          test('Rejects when query is not set', function() {
            const e = fire();
            let called = false;
            return e.detail.result
            .catch(() => {
              called = true;
            })
            .then(() => {
              assert.isTrue(called);
            });
          });

          test('Handles exceptions', () => {
            element.list = () => {
              return Promise.reject(new Error('test'));
            };
            const e = fire('test-id-non-existing');
            let called = false;
            return e.detail.result
            .catch((cause) => {
              if (cause.message === 'test') {
                called = true;
              }
            })
            .then(() => {
              assert.isTrue(called);
            });
          });
        });

        suite('websocket-url-history-list', function() {
          teardown(function() {
            return DataGenerator.destroyWebsocketsData();
          });

          let element;
          let dataObj;
          setup(function() {
            element = fixture('basic');
            dataObj = {
              _id: 'http://domain.com',
              cnt: 1,
              time: Date.now()
            };
            const e = fireChanged(dataObj);
            return e.detail.result
            .then((result) => dataObj = result);
          });

          function fire() {
            const e = new CustomEvent('websocket-url-history-list', {
              detail: {},
              bubbles: true,
              composed: true,
              cancelable: true
            });
            document.body.dispatchEvent(e);
            return e;
          }

          test('Ignores non-cancellable event', () => {
            const e = {
              cancelable: false,
              detail: {}
            };
            element._handleQueryHistory(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores cancelled event', () => {
            const e = {
              cancelable: true,
              defaultPrevented: true,
              detail: {}
            };
            element._handleQueryHistory(e);
            assert.isUndefined(e.detail.result);
          });

          test('Ignores self dispatched events', () => {
            const e = {
              cancelable: true,
              composedPath: function() {
                return [element];
              },
              detail: {}
            };
            element._handleQueryHistory(e);
            assert.isUndefined(e.detail.result);
          });

          test('Event is canceled', function() {
            const e = fire();
            assert.isTrue(e.defaultPrevented);
            return e.detail.result;
          });

          test('Event detail contains "result" as promise', function() {
            const e = fire();
            assert.typeOf(e.detail.result, 'promise');
            return e.detail.result;
          });

          test('Returns a list of history objects', function() {
            const e = fire();
            return e.detail.result
            .then((result) => {
              assert.typeOf(result, 'array', 'Result is an array');
              assert.lengthOf(result, 1, 'Length is OK');
            });
          });

          test('Returned items contains _time property', function() {
            const e = fire();
            return e.detail.result
            .then((result) => {
              assert.typeOf(result[0]._time, 'number', '_time is a number');
            });
          });

          test('Handles exceptions', () => {
            element.list = () => {
              return Promise.reject(new Error('test'));
            };
            const e = fire();
            let called = false;
            return e.detail.result
            .catch((cause) => {
              if (cause.message === 'test') {
                called = true;
              }
            })
            .then(() => {
              assert.isTrue(called);
            });
          });
        });

        suite('"destroy-model" event', () => {
          function fire(models) {
            const e = new CustomEvent('destroy-model', {
              detail: {
                models
              },
              bubbles: true
            });
            document.body.dispatchEvent(e);
            return e;
          }

          test('Deletes saved model', function() {
            fixture('basic');
            const e = fire(['websocket-url-history']);
            assert.typeOf(e.detail.result, 'array');
            assert.lengthOf(e.detail.result, 1);
            return Promise.all(e.detail.result);
          });

          test('Calls delete functions', function() {
            const element = fixture('basic');
            const spy = sinon.spy(element, 'deleteModel');
            const e = fire(['websocket-url-history']);
            assert.isTrue(spy.called);
            assert.equal(spy.args[0][0], 'websocket-url-history');
            return Promise.all(e.detail.result);
          });
        });
      });
    </script>

  </body>
</html>
