<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../../app-pouchdb/pouchdb.html">
    <link rel="import" href="../../websocket-url-history-model.html">
    <link rel="import" href="../../../arc-data-generator/arc-data-generator.html">
  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <websocket-url-history-model></websocket-url-history-model>
      </template>
    </test-fixture>

    <script>
    /* global DataGenerator */
    suite('Events API for websocket url history', function() {
      // See https://gist.github.com/haroldtreen/5f1055eee5fcf01da3e0e15b8ec86bf6
      function isError(e) {
        if (typeof e === 'string') {
          return Promise.reject(new Error(e));
        }
        return Promise.resolve(e);
      }

      function fireChanged(item) {
        const e = new CustomEvent('websocket-url-history-changed', {
          detail: {
            item: item
          },
          bubbles: true,
          composed: true,
          cancelable: true
        });
        document.body.dispatchEvent(e);
        return e;
      }

      suite('websocket-url-history-changed', function() {
        teardown(function() {
          return DataGenerator.destroyWebsocketsData();
        });

        let element;
        let dataObj;
        setup(function() {
          element = fixture('basic');
          dataObj = {
            _id: 'http://domain.com',
            cnt: 1,
            time: Date.now()
          };
        });

        test('Ignores non-cancellable event', () => {
          const e = {
            cancelable: false,
            detail: {
              item: dataObj
            }
          };
          element._handleChange(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores cancelled event', () => {
          const e = {
            cancelable: true,
            defaultPrevented: true,
            detail: {
              item: dataObj
            }
          };
          element._handleChange(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores self dispatched events', () => {
          const e = {
            cancelable: true,
            composedPath: function() {
              return [element];
            },
            detail: {
              item: dataObj
            }
          };
          element._handleChange(e);
          assert.isUndefined(e.detail.result);
        });

        test('Event is canceled', function() {
          const e = fireChanged(dataObj);
          assert.isTrue(e.defaultPrevented);
          return e.detail.result;
        });

        test('Event detail contains "result" as promise', function() {
          const e = fireChanged(dataObj);
          assert.typeOf(e.detail.result, 'promise');
          return e.detail.result;
        });

        test('Creates a new object in the datastore', function() {
          const e = fireChanged(dataObj);
          return e.detail.result
          .then((result) => {
            assert.typeOf(result._rev, 'string', '_rev is set');
            assert.typeOf(result._id, 'string', '_id is set');
            assert.equal(result.cnt, dataObj.cnt, 'cnt is set');
            assert.equal(result.time, dataObj.time, 'time is set');
          });
        });

        test('Updates created object', function() {
          let originalRev;
          let originalId;
          const e = fireChanged(dataObj);
          return e.detail.result
          .then((result) => {
            originalRev = result._rev;
            originalId = result._id;
            result.cnt = 2;
            const e = fireChanged(result);
            return e.detail.result;
          })
          .then((result) => {
            assert.notEqual(result._rev, originalRev, '_rev is regenerated');
            assert.equal(result._id, originalId, '_id is the same');
            assert.equal(result.cnt, 2, 'Name is set');
          });
        });

        test('Rejects promise when save object is not set', function() {
          const e = fireChanged();
          return e.detail.result
          .then(() => {
            return Promise.reject('Expected method to reject.');
          })
          .catch(isError)
          .then((err) => {
            assert.isDefined(err);
          });
        });

        test('Rejects promise when save object has no id', function() {
          const cp = Object.assign({}, dataObj);
          cp._id = undefined;
          const e = fireChanged(cp);
          return e.detail.result
          .then(() => {
            return Promise.reject('Expected method to reject.');
          })
          .catch(isError)
          .then((err) => {
            assert.isDefined(err);
          });
        });

        test('Handles exceptions', () => {
          const e = {
            cancelable: true,
            composedPath: () => [],
            preventDefault: () => {},
            stopPropagation: () => {},
            detail: {
              item: dataObj
            }
          };
          element.update = () => {
            return Promise.reject(new Error('test'));
          };
          let called = false;
          element._handleChange(e);
          return e.detail.result
          .catch((cause) => {
            if (cause.message === 'test') {
              called = true;
            }
          })
          .then(() => {
            assert.isTrue(called);
          });
        });
      });

      suite('websocket-url-history-read', function() {
        teardown(function() {
          return DataGenerator.destroyWebsocketsData();
        });

        let element;
        let dataObj;
        setup(function() {
          element = fixture('basic');
          dataObj = {
            _id: 'http://domain.com',
            cnt: 1,
            time: Date.now()
          };
          const e = fireChanged(dataObj);
          return e.detail.result
          .then((result) => dataObj = result);
        });

        function fire(id) {
          const e = new CustomEvent('websocket-url-history-read', {
            detail: {
              url: id
            },
            bubbles: true,
            composed: true,
            cancelable: true
          });
          document.body.dispatchEvent(e);
          return e;
        }

        test('Ignores non-cancellable event', () => {
          const element = fixture('basic');
          const e = {
            cancelable: false,
            detail: {
              url: dataObj._id
            }
          };
          element._handleRead(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores cancelled event', () => {
          const element = fixture('basic');
          const e = {
            cancelable: true,
            defaultPrevented: true,
            detail: {
              url: dataObj._id
            }
          };
          element._handleRead(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores self dispatched events', () => {
          const element = fixture('basic');
          const e = {
            cancelable: true,
            composedPath: function() {
              return [element];
            },
            detail: {
              url: dataObj._id
            }
          };
          element._handleRead(e);
          assert.isUndefined(e.detail.result);
        });

        test('Event is canceled', function() {
          const e = fire(dataObj._id);
          assert.isTrue(e.defaultPrevented);
          return e.detail.result;
        });

        test('Event detail contains "result" as promise', function() {
          const e = fire(dataObj._id);
          assert.typeOf(e.detail.result, 'promise');
          return e.detail.result;
        });

        test('Reads an object', function() {
          const e = fire(dataObj._id);
          return e.detail.result
          .then((result) => {
            assert.equal(result._id, dataObj._id);
          });
        });

        test('Rejects promise when no ID', function() {
          const e = fire();
          return e.detail.result
          .then(() => {
            return Promise.reject('Expected method to reject.');
          })
          .catch(isError)
          .then((err) => {
            assert.isDefined(err);
          });
        });

        test('Returns undefined when no object', function() {
          const e = fire('test-id-non-existing');
          return e.detail.result
          .then((result) => {
            assert.isUndefined(result);
          });
        });

        test('Handles exceptions', () => {
          element.read = () => {
            return Promise.reject(new Error('test'));
          };
          const e = fire('test-id-non-existing');
          let called = false;
          return e.detail.result
          .catch((cause) => {
            if (cause.message === 'test') {
              called = true;
            }
          })
          .then(() => {
            assert.isTrue(called);
          });
        });
      });

      suite('websocket-url-history-query', function() {
        teardown(function() {
          return DataGenerator.destroyWebsocketsData();
        });

        let element;
        let dataObj;
        setup(function() {
          element = fixture('basic');
          dataObj = {
            _id: 'http://domain.com',
            cnt: 1,
            time: Date.now()
          };
          const e = fireChanged(dataObj);
          return e.detail.result
          .then((result) => dataObj = result);
        });

        function fire(q) {
          const e = new CustomEvent('websocket-url-history-query', {
            detail: {
              q
            },
            bubbles: true,
            composed: true,
            cancelable: true
          });
          document.body.dispatchEvent(e);
          return e;
        }

        test('Ignores non-cancellable event', () => {
          const e = {
            cancelable: false,
            detail: {
              q: 'test'
            }
          };
          element._handleQuery(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores cancelled event', () => {
          const e = {
            cancelable: true,
            defaultPrevented: true,
            detail: {
              q: 'test'
            }
          };
          element._handleQuery(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores self dispatched events', () => {
          const e = {
            cancelable: true,
            composedPath: function() {
              return [element];
            },
            detail: {
              q: 'test'
            }
          };
          element._handleQuery(e);
          assert.isUndefined(e.detail.result);
        });

        test('Event is canceled', function() {
          const e = fire('http');
          assert.isTrue(e.defaultPrevented);
          return e.detail.result;
        });

        test('Event detail contains "result" as promise', function() {
          const e = fire('http');
          assert.typeOf(e.detail.result, 'promise');
          return e.detail.result;
        });

        test('Returns a list of results', function() {
          const e = fire('http');
          return e.detail.result
          .then((result) => {
            assert.typeOf(result, 'array', 'Result is an array');
            assert.lengthOf(result, 1, 'Length is OK');
          });
        });

        test('Returned items contains _time property', function() {
          const e = fire('http');
          return e.detail.result
          .then((result) => {
            assert.typeOf(result[0]._time, 'number', '_time is a number');
          });
        });

        test('Rejects when query is not set', function() {
          const e = fire();
          let called = false;
          return e.detail.result
          .catch(() => {
            called = true;
          })
          .then(() => {
            assert.isTrue(called);
          });
        });

        test('Handles exceptions', () => {
          element.list = () => {
            return Promise.reject(new Error('test'));
          };
          const e = fire('test-id-non-existing');
          let called = false;
          return e.detail.result
          .catch((cause) => {
            if (cause.message === 'test') {
              called = true;
            }
          })
          .then(() => {
            assert.isTrue(called);
          });
        });
      });

      suite('websocket-url-history-list', function() {
        teardown(function() {
          return DataGenerator.destroyWebsocketsData();
        });

        let element;
        let dataObj;
        setup(function() {
          element = fixture('basic');
          dataObj = {
            _id: 'http://domain.com',
            cnt: 1,
            time: Date.now()
          };
          const e = fireChanged(dataObj);
          return e.detail.result
          .then((result) => dataObj = result);
        });

        function fire() {
          const e = new CustomEvent('websocket-url-history-list', {
            detail: {},
            bubbles: true,
            composed: true,
            cancelable: true
          });
          document.body.dispatchEvent(e);
          return e;
        }

        test('Ignores non-cancellable event', () => {
          const e = {
            cancelable: false,
            detail: {}
          };
          element._handleQueryHistory(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores cancelled event', () => {
          const e = {
            cancelable: true,
            defaultPrevented: true,
            detail: {}
          };
          element._handleQueryHistory(e);
          assert.isUndefined(e.detail.result);
        });

        test('Ignores self dispatched events', () => {
          const e = {
            cancelable: true,
            composedPath: function() {
              return [element];
            },
            detail: {}
          };
          element._handleQueryHistory(e);
          assert.isUndefined(e.detail.result);
        });

        test('Event is canceled', function() {
          const e = fire();
          assert.isTrue(e.defaultPrevented);
          return e.detail.result;
        });

        test('Event detail contains "result" as promise', function() {
          const e = fire();
          assert.typeOf(e.detail.result, 'promise');
          return e.detail.result;
        });

        test('Returns a list of history objects', function() {
          const e = fire();
          return e.detail.result
          .then((result) => {
            assert.typeOf(result, 'array', 'Result is an array');
            assert.lengthOf(result, 1, 'Length is OK');
          });
        });

        test('Returned items contains _time property', function() {
          const e = fire();
          return e.detail.result
          .then((result) => {
            assert.typeOf(result[0]._time, 'number', '_time is a number');
          });
        });

        test('Handles exceptions', () => {
          element.list = () => {
            return Promise.reject(new Error('test'));
          };
          const e = fire();
          let called = false;
          return e.detail.result
          .catch((cause) => {
            if (cause.message === 'test') {
              called = true;
            }
          })
          .then(() => {
            assert.isTrue(called);
          });
        });
      });
    });
    </script>

  </body>
</html>
